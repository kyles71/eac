diff --git a/app/Actions/Store/AddToCart.php b/app/Actions/Store/AddToCart.php
new file mode 100644
index 0000000..c5c5578
--- /dev/null
+++ b/app/Actions/Store/AddToCart.php
@@ -0,0 +1,61 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Actions\Store;
+
+use App\Models\CartItem;
+use App\Models\Course;
+use App\Models\Product;
+use App\Models\User;
+use Illuminate\Support\Facades\DB;
+use InvalidArgumentException;
+
+final readonly class AddToCart
+{
+    public function handle(User $user, Product $product, int $quantity = 1): CartItem
+    {
+        return DB::transaction(function () use ($user, $product, $quantity): CartItem {
+            if (! $product->is_active) {
+                throw new InvalidArgumentException('This product is not available for purchase.');
+            }
+
+            if ($product->price <= 0) {
+                throw new InvalidArgumentException('This product does not have a valid price.');
+            }
+
+            if ($product->productable instanceof Course) {
+                $availableCapacity = $product->productable->availableCapacity();
+                $existingQuantity = CartItem::query()
+                    ->where('user_id', $user->id)
+                    ->where('product_id', $product->id)
+                    ->value('quantity') ?? 0;
+
+                $totalRequested = $existingQuantity + $quantity;
+
+                if ($totalRequested > $availableCapacity) {
+                    throw new InvalidArgumentException(
+                        "Only {$availableCapacity} spot(s) remaining for this course."
+                    );
+                }
+            }
+
+            $cartItem = CartItem::query()
+                ->where('user_id', $user->id)
+                ->where('product_id', $product->id)
+                ->first();
+
+            if ($cartItem !== null) {
+                $cartItem->increment('quantity', $quantity);
+
+                return $cartItem->refresh();
+            }
+
+            return CartItem::query()->create([
+                'user_id' => $user->id,
+                'product_id' => $product->id,
+                'quantity' => $quantity,
+            ]);
+        });
+    }
+}
diff --git a/app/Actions/Store/CompleteOrder.php b/app/Actions/Store/CompleteOrder.php
new file mode 100644
index 0000000..5f90c2f
--- /dev/null
+++ b/app/Actions/Store/CompleteOrder.php
@@ -0,0 +1,99 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Actions\Store;
+
+use App\Contracts\StripeServiceContract;
+use App\Enums\OrderStatus;
+use App\Models\Course;
+use App\Models\Enrollment;
+use App\Models\Order;
+use Illuminate\Support\Facades\DB;
+use Illuminate\Support\Facades\Log;
+
+final readonly class CompleteOrder
+{
+    public function __construct(
+        private StripeServiceContract $stripeService,
+    ) {}
+
+    public function handle(Order $order): bool
+    {
+        return DB::transaction(function () use ($order): bool {
+            $order->loadMissing('orderItems.product.productable');
+
+            // Verify order is still pending
+            if ($order->status !== OrderStatus::Pending) {
+                Log::warning("Order #{$order->id} is not pending, skipping completion.", [
+                    'status' => $order->status->value,
+                ]);
+
+                return false;
+            }
+
+            // Atomic capacity check with row-level locks
+            /** @var \App\Models\OrderItem $orderItem */
+            foreach ($order->orderItems as $orderItem) {
+                /** @var \App\Models\Product $product */
+                $product = $orderItem->product;
+
+                if (! ($product->productable instanceof Course)) {
+                    continue;
+                }
+
+                // Lock the course row to prevent concurrent overselling
+                /** @var Course $course */
+                $course = Course::query()
+                    ->lockForUpdate()
+                    ->find($product->productable->id);
+
+                $availableCapacity = $course->availableCapacity();
+
+                if ($orderItem->quantity > $availableCapacity) {
+                    Log::warning("Order #{$order->id} failed: insufficient capacity for course #{$course->id}.", [
+                        'requested' => $orderItem->quantity,
+                        'available' => $availableCapacity,
+                    ]);
+
+                    $order->update(['status' => OrderStatus::Failed]);
+
+                    // Refund the payment
+                    if ($order->stripe_payment_intent_id !== null) {
+                        $this->stripeService->refundPaymentIntent($order->stripe_payment_intent_id);
+                    }
+
+                    return false;
+                }
+            }
+
+            // Create enrollments for course products
+            /** @var \App\Models\OrderItem $orderItem */
+            foreach ($order->orderItems as $orderItem) {
+                /** @var \App\Models\Product $product */
+                $product = $orderItem->product;
+
+                if (! ($product->productable instanceof Course)) {
+                    continue;
+                }
+
+                for ($i = 0; $i < $orderItem->quantity; $i++) {
+                    Enrollment::query()->create([
+                        'course_id' => $product->productable->id,
+                        'user_id' => $order->user_id,
+                        'student_id' => null,
+                    ]);
+                }
+            }
+
+            $order->update(['status' => OrderStatus::Completed]);
+
+            // Clear the user's cart
+            /** @var \App\Models\User $user */
+            $user = $order->user;
+            $user->cartItems()->delete();
+
+            return true;
+        });
+    }
+}
diff --git a/app/Actions/Store/CreateCheckoutSession.php b/app/Actions/Store/CreateCheckoutSession.php
new file mode 100644
index 0000000..337afb2
--- /dev/null
+++ b/app/Actions/Store/CreateCheckoutSession.php
@@ -0,0 +1,106 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Actions\Store;
+
+use App\Contracts\StripeServiceContract;
+use App\Enums\OrderStatus;
+use App\Models\Course;
+use App\Models\Order;
+use App\Models\User;
+use Illuminate\Support\Facades\DB;
+use InvalidArgumentException;
+
+final readonly class CreateCheckoutSession
+{
+    public function __construct(
+        private StripeServiceContract $stripeService,
+    ) {}
+
+    public function handle(User $user, string $successUrl, string $cancelUrl): string
+    {
+        return DB::transaction(function () use ($user, $successUrl, $cancelUrl): string {
+            $cartItems = $user->cartItems()->with('product.productable')->get();
+
+            if ($cartItems->isEmpty()) {
+                throw new InvalidArgumentException('Your cart is empty.');
+            }
+
+            // Soft capacity pre-check
+            /** @var \App\Models\CartItem $cartItem */
+            foreach ($cartItems as $cartItem) {
+                /** @var \App\Models\Product $product */
+                $product = $cartItem->product;
+                if ($product->productable instanceof Course) {
+                    $available = $product->productable->availableCapacity();
+                    if ($cartItem->quantity > $available) {
+                        throw new InvalidArgumentException(
+                            "Not enough spots available for \"{$product->name}\". Only {$available} remaining."
+                        );
+                    }
+                }
+            }
+
+            // Calculate totals and create order
+            $subtotal = 0;
+            $orderItems = [];
+            $lineItems = [];
+
+            /** @var \App\Models\CartItem $cartItem */
+            foreach ($cartItems as $cartItem) {
+                /** @var \App\Models\Product $product */
+                $product = $cartItem->product;
+                $unitPrice = $product->price;
+                $totalPrice = $unitPrice * $cartItem->quantity;
+                $subtotal += $totalPrice;
+
+                $orderItems[] = [
+                    'product_id' => $product->id,
+                    'quantity' => $cartItem->quantity,
+                    'unit_price' => $unitPrice,
+                    'total_price' => $totalPrice,
+                ];
+
+                $lineItems[] = [
+                    'price_data' => [
+                        'currency' => 'usd',
+                        'product_data' => [
+                            'name' => $product->name,
+                        ],
+                        'unit_amount' => $unitPrice,
+                    ],
+                    'quantity' => $cartItem->quantity,
+                ];
+            }
+
+            $order = Order::query()->create([
+                'user_id' => $user->id,
+                'status' => OrderStatus::Pending,
+                'subtotal' => $subtotal,
+                'total' => $subtotal,
+            ]);
+
+            foreach ($orderItems as $item) {
+                $order->orderItems()->create($item);
+            }
+
+            // Create Stripe Checkout Session
+            $session = $this->stripeService->createCheckoutSession(
+                user: $user,
+                lineItems: $lineItems,
+                successUrl: $successUrl.'?session_id={CHECKOUT_SESSION_ID}',
+                cancelUrl: $cancelUrl,
+                metadata: [
+                    'order_id' => (string) $order->id,
+                ],
+            );
+
+            $order->update([
+                'stripe_checkout_session_id' => $session->id,
+            ]);
+
+            return $session->url;
+        });
+    }
+}
diff --git a/app/Actions/Store/RemoveFromCart.php b/app/Actions/Store/RemoveFromCart.php
new file mode 100644
index 0000000..eafc2fd
--- /dev/null
+++ b/app/Actions/Store/RemoveFromCart.php
@@ -0,0 +1,27 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Actions\Store;
+
+use App\Models\CartItem;
+use App\Models\User;
+use Illuminate\Support\Facades\DB;
+use InvalidArgumentException;
+
+final readonly class RemoveFromCart
+{
+    public function handle(User $user, int $cartItemId): void
+    {
+        DB::transaction(function () use ($user, $cartItemId): void {
+            $deleted = CartItem::query()
+                ->where('id', $cartItemId)
+                ->where('user_id', $user->id)
+                ->delete();
+
+            if ($deleted === 0) {
+                throw new InvalidArgumentException('Cart item not found.');
+            }
+        });
+    }
+}
diff --git a/app/Actions/Store/UpdateCartQuantity.php b/app/Actions/Store/UpdateCartQuantity.php
new file mode 100644
index 0000000..8c307d8
--- /dev/null
+++ b/app/Actions/Store/UpdateCartQuantity.php
@@ -0,0 +1,50 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Actions\Store;
+
+use App\Models\CartItem;
+use App\Models\Course;
+use App\Models\User;
+use Illuminate\Support\Facades\DB;
+use InvalidArgumentException;
+
+final readonly class UpdateCartQuantity
+{
+    public function handle(User $user, int $cartItemId, int $quantity): CartItem
+    {
+        return DB::transaction(function () use ($user, $cartItemId, $quantity): CartItem {
+            $cartItem = CartItem::query()
+                ->where('id', $cartItemId)
+                ->where('user_id', $user->id)
+                ->with('product.productable')
+                ->first();
+
+            if ($cartItem === null) {
+                throw new InvalidArgumentException('Cart item not found.');
+            }
+
+            if ($quantity < 1) {
+                throw new InvalidArgumentException('Quantity must be at least 1.');
+            }
+
+            /** @var \App\Models\Product $product */
+            $product = $cartItem->product;
+
+            if ($product->productable instanceof Course) {
+                $availableCapacity = $product->productable->availableCapacity();
+
+                if ($quantity > $availableCapacity) {
+                    throw new InvalidArgumentException(
+                        "Only {$availableCapacity} spot(s) remaining for this course."
+                    );
+                }
+            }
+
+            $cartItem->update(['quantity' => $quantity]);
+
+            return $cartItem->refresh();
+        });
+    }
+}
diff --git a/app/Contracts/StripeServiceContract.php b/app/Contracts/StripeServiceContract.php
new file mode 100644
index 0000000..eb52c23
--- /dev/null
+++ b/app/Contracts/StripeServiceContract.php
@@ -0,0 +1,32 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Contracts;
+
+use App\Models\User;
+use Stripe\Checkout\Session as StripeSession;
+use Stripe\Customer;
+use Stripe\Event;
+use Stripe\Refund;
+
+interface StripeServiceContract
+{
+    public function createOrGetCustomer(User $user): Customer;
+
+    /**
+     * @param  array<int, array<string, mixed>>  $lineItems
+     * @param  array<string, string>  $metadata
+     */
+    public function createCheckoutSession(
+        User $user,
+        array $lineItems,
+        string $successUrl,
+        string $cancelUrl,
+        array $metadata = [],
+    ): StripeSession;
+
+    public function constructWebhookEvent(string $payload, string $signature): Event;
+
+    public function refundPaymentIntent(string $paymentIntentId, ?int $amount = null): Refund;
+}
diff --git a/app/Enums/OrderStatus.php b/app/Enums/OrderStatus.php
new file mode 100644
index 0000000..2cb02e5
--- /dev/null
+++ b/app/Enums/OrderStatus.php
@@ -0,0 +1,20 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Enums;
+
+use Filament\Support\Contracts\HasLabel;
+
+enum OrderStatus: string implements HasLabel
+{
+    case Pending = 'Pending';
+    case Completed = 'Completed';
+    case Failed = 'Failed';
+    case Refunded = 'Refunded';
+
+    public function getLabel(): string
+    {
+        return $this->value;
+    }
+}
diff --git a/app/Filament/Admin/Resources/Courses/Schemas/CourseInfolist.php b/app/Filament/Admin/Resources/Courses/Schemas/CourseInfolist.php
index 72d337c..7da7d50 100644
--- a/app/Filament/Admin/Resources/Courses/Schemas/CourseInfolist.php
+++ b/app/Filament/Admin/Resources/Courses/Schemas/CourseInfolist.php
@@ -4,6 +4,7 @@
 
 namespace App\Filament\Admin\Resources\Courses\Schemas;
 
+use App\Models\Course;
 use Filament\Infolists\Components\TextEntry;
 use Filament\Schemas\Schema;
 
@@ -16,6 +17,15 @@ public static function configure(Schema $schema): Schema
                 TextEntry::make('name'),
                 TextEntry::make('capacity')
                     ->numeric(),
+                TextEntry::make('available_capacity')
+                    ->label('Available Spots')
+                    ->state(fn (Course $record): int => $record->availableCapacity())
+                    ->badge()
+                    ->color(fn (Course $record): string => $record->availableCapacity() > 0 ? 'success' : 'danger'),
+                TextEntry::make('product.price')
+                    ->label('Price')
+                    ->formatStateUsing(fn (?int $state): string => $state !== null ? '$'.number_format($state / 100, 2) : 'No product linked')
+                    ->placeholder('No product linked'),
                 TextEntry::make('start_time')
                     ->dateTime(),
                 TextEntry::make('duration')
diff --git a/app/Filament/Admin/Resources/Courses/Tables/CoursesTable.php b/app/Filament/Admin/Resources/Courses/Tables/CoursesTable.php
index b4ade67..29d9a85 100644
--- a/app/Filament/Admin/Resources/Courses/Tables/CoursesTable.php
+++ b/app/Filament/Admin/Resources/Courses/Tables/CoursesTable.php
@@ -4,6 +4,7 @@
 
 namespace App\Filament\Admin\Resources\Courses\Tables;
 
+use App\Models\Course;
 use Filament\Actions\BulkActionGroup;
 use Filament\Actions\DeleteBulkAction;
 use Filament\Tables\Columns\TextColumn;
@@ -17,9 +18,18 @@ public static function configure(Table $table): Table
             ->columns([
                 TextColumn::make('name')
                     ->searchable(),
+                TextColumn::make('product.price')
+                    ->label('Price')
+                    ->formatStateUsing(fn (?int $state): string => $state !== null ? '$'.number_format($state / 100, 2) : 'â€”')
+                    ->placeholder('No product'),
                 TextColumn::make('capacity')
                     ->numeric()
                     ->sortable(),
+                TextColumn::make('available_capacity')
+                    ->label('Available')
+                    ->state(fn (Course $record): int => $record->availableCapacity())
+                    ->badge()
+                    ->color(fn (Course $record): string => $record->availableCapacity() > 0 ? 'success' : 'danger'),
                 TextColumn::make('start_time')
                     ->dateTime()
                     ->sortable(),
diff --git a/app/Filament/Admin/Resources/Orders/OrderResource.php b/app/Filament/Admin/Resources/Orders/OrderResource.php
new file mode 100644
index 0000000..50b1858
--- /dev/null
+++ b/app/Filament/Admin/Resources/Orders/OrderResource.php
@@ -0,0 +1,49 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Filament\Admin\Resources\Orders;
+
+use App\Filament\Admin\Resources\Orders\Pages\ListOrders;
+use App\Filament\Admin\Resources\Orders\Pages\ViewOrder;
+use App\Filament\Admin\Resources\Orders\Schemas\OrderInfolist;
+use App\Filament\Admin\Resources\Orders\Tables\OrdersTable;
+use App\Models\Order;
+use BackedEnum;
+use Filament\Resources\Resource;
+use Filament\Schemas\Schema;
+use Filament\Support\Icons\Heroicon;
+use Filament\Tables\Table;
+use UnitEnum;
+
+final class OrderResource extends Resource
+{
+    protected static ?string $model = Order::class;
+
+    protected static string|BackedEnum|null $navigationIcon = Heroicon::OutlinedShoppingCart;
+
+    protected static UnitEnum|string|null $navigationGroup = 'Store';
+
+    public static function infolist(Schema $schema): Schema
+    {
+        return OrderInfolist::configure($schema);
+    }
+
+    public static function table(Table $table): Table
+    {
+        return OrdersTable::configure($table);
+    }
+
+    public static function getRelations(): array
+    {
+        return [];
+    }
+
+    public static function getPages(): array
+    {
+        return [
+            'index' => ListOrders::route('/'),
+            'view' => ViewOrder::route('/{record}'),
+        ];
+    }
+}
diff --git a/app/Filament/Admin/Resources/Orders/Pages/ListOrders.php b/app/Filament/Admin/Resources/Orders/Pages/ListOrders.php
new file mode 100644
index 0000000..0de2a2c
--- /dev/null
+++ b/app/Filament/Admin/Resources/Orders/Pages/ListOrders.php
@@ -0,0 +1,13 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Filament\Admin\Resources\Orders\Pages;
+
+use App\Filament\Admin\Resources\Orders\OrderResource;
+use Filament\Resources\Pages\ListRecords;
+
+final class ListOrders extends ListRecords
+{
+    protected static string $resource = OrderResource::class;
+}
diff --git a/app/Filament/Admin/Resources/Orders/Pages/ViewOrder.php b/app/Filament/Admin/Resources/Orders/Pages/ViewOrder.php
new file mode 100644
index 0000000..2e32308
--- /dev/null
+++ b/app/Filament/Admin/Resources/Orders/Pages/ViewOrder.php
@@ -0,0 +1,57 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Filament\Admin\Resources\Orders\Pages;
+
+use App\Enums\OrderStatus;
+use App\Filament\Admin\Resources\Orders\OrderResource;
+use App\Services\StripeService;
+use Exception;
+use Filament\Actions\Action;
+use Filament\Notifications\Notification;
+use Filament\Resources\Pages\ViewRecord;
+use Filament\Support\Icons\Heroicon;
+
+final class ViewOrder extends ViewRecord
+{
+    protected static string $resource = OrderResource::class;
+
+    protected function getHeaderActions(): array
+    {
+        /** @var \App\Models\Order $record */
+        $record = $this->getRecord();
+
+        return [
+            Action::make('refund')
+                ->label('Refund')
+                ->icon(Heroicon::OutlinedArrowUturnLeft)
+                ->color('danger')
+                ->visible(fn (): bool => $record->status === OrderStatus::Completed && $record->stripe_payment_intent_id !== null)
+                ->requiresConfirmation()
+                ->modalHeading('Refund Order')
+                ->modalDescription('Are you sure you want to refund this order? This action cannot be undone.')
+                ->action(function () use ($record): void {
+                    $stripeService = app(StripeService::class);
+
+                    try {
+                        $stripeService->refundPaymentIntent($record->stripe_payment_intent_id);
+
+                        $record->update(['status' => OrderStatus::Refunded]);
+
+                        Notification::make()
+                            ->title('Order refunded')
+                            ->body("Order #{$record->id} has been refunded successfully.")
+                            ->success()
+                            ->send();
+                    } catch (Exception $e) {
+                        Notification::make()
+                            ->title('Refund failed')
+                            ->body($e->getMessage())
+                            ->danger()
+                            ->send();
+                    }
+                }),
+        ];
+    }
+}
diff --git a/app/Filament/Admin/Resources/Orders/Schemas/OrderInfolist.php b/app/Filament/Admin/Resources/Orders/Schemas/OrderInfolist.php
new file mode 100644
index 0000000..ba5bb44
--- /dev/null
+++ b/app/Filament/Admin/Resources/Orders/Schemas/OrderInfolist.php
@@ -0,0 +1,69 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Filament\Admin\Resources\Orders\Schemas;
+
+use App\Enums\OrderStatus;
+use Filament\Infolists\Components\RepeatableEntry;
+use Filament\Infolists\Components\TextEntry;
+use Filament\Schemas\Components\Section;
+use Filament\Schemas\Schema;
+
+final class OrderInfolist
+{
+    public static function configure(Schema $schema): Schema
+    {
+        return $schema
+            ->components([
+                Section::make('Order Information')
+                    ->schema([
+                        TextEntry::make('id')
+                            ->label('Order #'),
+                        TextEntry::make('user.full_name')
+                            ->label('Customer'),
+                        TextEntry::make('user.email')
+                            ->label('Email'),
+                        TextEntry::make('status')
+                            ->badge()
+                            ->color(fn (OrderStatus $state): string => match ($state) {
+                                OrderStatus::Completed => 'success',
+                                OrderStatus::Pending => 'warning',
+                                OrderStatus::Failed => 'danger',
+                                OrderStatus::Refunded => 'gray',
+                            }),
+                        TextEntry::make('subtotal')
+                            ->formatStateUsing(fn (int $state): string => '$'.number_format($state / 100, 2)),
+                        TextEntry::make('total')
+                            ->formatStateUsing(fn (int $state): string => '$'.number_format($state / 100, 2)),
+                        TextEntry::make('stripe_checkout_session_id')
+                            ->label('Stripe Session ID')
+                            ->placeholder('N/A')
+                            ->copyable(),
+                        TextEntry::make('stripe_payment_intent_id')
+                            ->label('Stripe Payment Intent')
+                            ->placeholder('N/A')
+                            ->copyable(),
+                        TextEntry::make('created_at')
+                            ->label('Ordered At')
+                            ->dateTime(),
+                    ]),
+                Section::make('Order Items')
+                    ->schema([
+                        RepeatableEntry::make('orderItems')
+                            ->hiddenLabel()
+                            ->schema([
+                                TextEntry::make('product.name')
+                                    ->label('Product'),
+                                TextEntry::make('quantity'),
+                                TextEntry::make('unit_price')
+                                    ->label('Unit Price')
+                                    ->formatStateUsing(fn (int $state): string => '$'.number_format($state / 100, 2)),
+                                TextEntry::make('total_price')
+                                    ->label('Total')
+                                    ->formatStateUsing(fn (int $state): string => '$'.number_format($state / 100, 2)),
+                            ]),
+                    ]),
+            ]);
+    }
+}
diff --git a/app/Filament/Admin/Resources/Orders/Tables/OrdersTable.php b/app/Filament/Admin/Resources/Orders/Tables/OrdersTable.php
new file mode 100644
index 0000000..55c6ec0
--- /dev/null
+++ b/app/Filament/Admin/Resources/Orders/Tables/OrdersTable.php
@@ -0,0 +1,59 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Filament\Admin\Resources\Orders\Tables;
+
+use App\Enums\OrderStatus;
+use Filament\Tables\Columns\TextColumn;
+use Filament\Tables\Filters\SelectFilter;
+use Filament\Tables\Table;
+
+final class OrdersTable
+{
+    public static function configure(Table $table): Table
+    {
+        return $table
+            ->columns([
+                TextColumn::make('id')
+                    ->label('Order #')
+                    ->sortable(),
+                TextColumn::make('user.full_name')
+                    ->label('Customer')
+                    ->searchable(['first_name', 'last_name']),
+                TextColumn::make('user.email')
+                    ->label('Email')
+                    ->searchable(),
+                TextColumn::make('status')
+                    ->badge()
+                    ->color(fn (OrderStatus $state): string => match ($state) {
+                        OrderStatus::Completed => 'success',
+                        OrderStatus::Pending => 'warning',
+                        OrderStatus::Failed => 'danger',
+                        OrderStatus::Refunded => 'gray',
+                    }),
+                TextColumn::make('total')
+                    ->formatStateUsing(fn (int $state): string => '$'.number_format($state / 100, 2))
+                    ->sortable(),
+                TextColumn::make('created_at')
+                    ->label('Date')
+                    ->dateTime()
+                    ->sortable(),
+                TextColumn::make('updated_at')
+                    ->dateTime()
+                    ->sortable()
+                    ->toggleable(isToggledHiddenByDefault: true),
+            ])
+            ->defaultSort('created_at', 'desc')
+            ->filters([
+                SelectFilter::make('status')
+                    ->options(OrderStatus::class),
+            ])
+            ->recordActions([
+
+            ])
+            ->toolbarActions([
+
+            ]);
+    }
+}
diff --git a/app/Filament/Admin/Resources/Products/Pages/ListProducts.php b/app/Filament/Admin/Resources/Products/Pages/ListProducts.php
new file mode 100644
index 0000000..eba75f7
--- /dev/null
+++ b/app/Filament/Admin/Resources/Products/Pages/ListProducts.php
@@ -0,0 +1,21 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Filament\Admin\Resources\Products\Pages;
+
+use App\Filament\Admin\Resources\Products\ProductResource;
+use Filament\Actions\CreateAction;
+use Filament\Resources\Pages\ListRecords;
+
+final class ListProducts extends ListRecords
+{
+    protected static string $resource = ProductResource::class;
+
+    protected function getHeaderActions(): array
+    {
+        return [
+            CreateAction::make(),
+        ];
+    }
+}
diff --git a/app/Filament/Admin/Resources/Products/Pages/ViewProduct.php b/app/Filament/Admin/Resources/Products/Pages/ViewProduct.php
new file mode 100644
index 0000000..7d1dafb
--- /dev/null
+++ b/app/Filament/Admin/Resources/Products/Pages/ViewProduct.php
@@ -0,0 +1,21 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Filament\Admin\Resources\Products\Pages;
+
+use App\Filament\Admin\Resources\Products\ProductResource;
+use Filament\Actions\EditAction;
+use Filament\Resources\Pages\ViewRecord;
+
+final class ViewProduct extends ViewRecord
+{
+    protected static string $resource = ProductResource::class;
+
+    protected function getHeaderActions(): array
+    {
+        return [
+            EditAction::make(),
+        ];
+    }
+}
diff --git a/app/Filament/Admin/Resources/Products/ProductResource.php b/app/Filament/Admin/Resources/Products/ProductResource.php
new file mode 100644
index 0000000..1a8ff42
--- /dev/null
+++ b/app/Filament/Admin/Resources/Products/ProductResource.php
@@ -0,0 +1,64 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Filament\Admin\Resources\Products;
+
+use App\Filament\Admin\Resources\Products\Pages\ListProducts;
+use App\Filament\Admin\Resources\Products\Pages\ViewProduct;
+use App\Filament\Admin\Resources\Products\Schemas\ProductForm;
+use App\Filament\Admin\Resources\Products\Schemas\ProductInfolist;
+use App\Filament\Admin\Resources\Products\Tables\ProductsTable;
+use App\Models\Product;
+use BackedEnum;
+use Filament\Resources\Resource;
+use Filament\Schemas\Schema;
+use Filament\Support\Icons\Heroicon;
+use Filament\Tables\Table;
+use UnitEnum;
+
+final class ProductResource extends Resource
+{
+    protected static ?string $model = Product::class;
+
+    protected static string|BackedEnum|null $navigationIcon = Heroicon::OutlinedShoppingBag;
+
+    protected static UnitEnum|string|null $navigationGroup = 'Store';
+
+    protected static ?string $recordTitleAttribute = 'name';
+
+    public static function getGloballySearchableAttributes(): array
+    {
+        return [
+            'name',
+        ];
+    }
+
+    public static function form(Schema $schema): Schema
+    {
+        return ProductForm::configure($schema);
+    }
+
+    public static function infolist(Schema $schema): Schema
+    {
+        return ProductInfolist::configure($schema);
+    }
+
+    public static function table(Table $table): Table
+    {
+        return ProductsTable::configure($table);
+    }
+
+    public static function getRelations(): array
+    {
+        return [];
+    }
+
+    public static function getPages(): array
+    {
+        return [
+            'index' => ListProducts::route('/'),
+            'view' => ViewProduct::route('/{record}'),
+        ];
+    }
+}
diff --git a/app/Filament/Admin/Resources/Products/Schemas/ProductForm.php b/app/Filament/Admin/Resources/Products/Schemas/ProductForm.php
new file mode 100644
index 0000000..2fe6dae
--- /dev/null
+++ b/app/Filament/Admin/Resources/Products/Schemas/ProductForm.php
@@ -0,0 +1,60 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Filament\Admin\Resources\Products\Schemas;
+
+use App\Models\Course;
+use Filament\Forms\Components\Select;
+use Filament\Forms\Components\Textarea;
+use Filament\Forms\Components\TextInput;
+use Filament\Forms\Components\Toggle;
+use Filament\Schemas\Schema;
+use Illuminate\Database\Eloquent\Builder;
+
+final class ProductForm
+{
+    public static function configure(Schema $schema): Schema
+    {
+        return $schema
+            ->components([
+                TextInput::make('name')
+                    ->required()
+                    ->maxLength(255),
+                Textarea::make('description')
+                    ->columnSpanFull(),
+                TextInput::make('price')
+                    ->required()
+                    ->numeric()
+                    ->prefix('$')
+                    ->formatStateUsing(fn (?int $state): ?string => $state !== null ? number_format($state / 100, 2, '.', '') : null)
+                    ->dehydrateStateUsing(fn (?string $state): ?int => $state !== null ? (int) round((float) $state * 100) : null)
+                    ->minValue(0),
+                Toggle::make('is_active')
+                    ->label('Active')
+                    ->default(true),
+                Select::make('productable_type')
+                    ->label('Product Type')
+                    ->options([
+                        Course::class => 'Course',
+                    ])
+                    ->reactive(),
+                Select::make('productable_id')
+                    ->label('Linked Course')
+                    ->options(fn () => Course::query()->orderBy('name')->pluck('name', 'id'))
+                    ->searchable()
+                    ->visible(fn (callable $get): bool => $get('productable_type') === Course::class),
+                Select::make('requires_course_id')
+                    ->label('Requires Enrollment In')
+                    ->helperText('Only visible to users enrolled in this course.')
+                    ->relationship(
+                        name: 'requiresCourse',
+                        titleAttribute: 'name',
+                        modifyQueryUsing: fn (Builder $query) => $query->orderBy('name'),
+                    )
+                    ->nullable()
+                    ->searchable()
+                    ->preload(),
+            ]);
+    }
+}
diff --git a/app/Filament/Admin/Resources/Products/Schemas/ProductInfolist.php b/app/Filament/Admin/Resources/Products/Schemas/ProductInfolist.php
new file mode 100644
index 0000000..dd9d7e7
--- /dev/null
+++ b/app/Filament/Admin/Resources/Products/Schemas/ProductInfolist.php
@@ -0,0 +1,48 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Filament\Admin\Resources\Products\Schemas;
+
+use App\Models\Course;
+use App\Models\Product;
+use Filament\Infolists\Components\TextEntry;
+use Filament\Schemas\Schema;
+
+final class ProductInfolist
+{
+    public static function configure(Schema $schema): Schema
+    {
+        return $schema
+            ->components([
+                TextEntry::make('name'),
+                TextEntry::make('description'),
+                TextEntry::make('price')
+                    ->formatStateUsing(fn (int $state): string => '$'.number_format($state / 100, 2)),
+                TextEntry::make('is_active')
+                    ->label('Status')
+                    ->badge()
+                    ->formatStateUsing(fn (bool $state): string => $state ? 'Active' : 'Inactive')
+                    ->color(fn (bool $state): string => $state ? 'success' : 'danger'),
+                TextEntry::make('productable_type')
+                    ->label('Product Type')
+                    ->formatStateUsing(fn (?string $state): string => match ($state) {
+                        Course::class => 'Course',
+                        default => $state ?? 'None',
+                    }),
+                TextEntry::make('productable.name')
+                    ->label('Linked To')
+                    ->visible(fn (Product $record): bool => $record->productable !== null),
+                TextEntry::make('requiresCourse.name')
+                    ->label('Requires Enrollment In')
+                    ->placeholder('None'),
+                TextEntry::make('order_items_count')
+                    ->label('Times Ordered')
+                    ->state(fn (Product $record): int => $record->orderItems()->count()),
+                TextEntry::make('created_at')
+                    ->dateTime(),
+                TextEntry::make('updated_at')
+                    ->dateTime(),
+            ]);
+    }
+}
diff --git a/app/Filament/Admin/Resources/Products/Tables/ProductsTable.php b/app/Filament/Admin/Resources/Products/Tables/ProductsTable.php
new file mode 100644
index 0000000..bf1f288
--- /dev/null
+++ b/app/Filament/Admin/Resources/Products/Tables/ProductsTable.php
@@ -0,0 +1,57 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Filament\Admin\Resources\Products\Tables;
+
+use Filament\Actions\BulkActionGroup;
+use Filament\Actions\DeleteBulkAction;
+use Filament\Tables\Columns\IconColumn;
+use Filament\Tables\Columns\TextColumn;
+use Filament\Tables\Filters\TernaryFilter;
+use Filament\Tables\Table;
+
+final class ProductsTable
+{
+    public static function configure(Table $table): Table
+    {
+        return $table
+            ->columns([
+                TextColumn::make('name')
+                    ->searchable()
+                    ->sortable(),
+                TextColumn::make('price')
+                    ->formatStateUsing(fn (int $state): string => '$'.number_format($state / 100, 2))
+                    ->sortable(),
+                IconColumn::make('is_active')
+                    ->label('Active')
+                    ->boolean(),
+                TextColumn::make('productable_type')
+                    ->label('Type')
+                    ->formatStateUsing(fn (?string $state): string => match ($state) {
+                        'App\\Models\\Course' => 'Course',
+                        default => $state ?? 'General',
+                    }),
+                TextColumn::make('created_at')
+                    ->dateTime()
+                    ->sortable()
+                    ->toggleable(isToggledHiddenByDefault: true),
+                TextColumn::make('updated_at')
+                    ->dateTime()
+                    ->sortable()
+                    ->toggleable(isToggledHiddenByDefault: true),
+            ])
+            ->filters([
+                TernaryFilter::make('is_active')
+                    ->label('Active'),
+            ])
+            ->recordActions([
+
+            ])
+            ->toolbarActions([
+                BulkActionGroup::make([
+                    DeleteBulkAction::make(),
+                ]),
+            ]);
+    }
+}
diff --git a/app/Filament/User/Pages/Cart.php b/app/Filament/User/Pages/Cart.php
new file mode 100644
index 0000000..879536a
--- /dev/null
+++ b/app/Filament/User/Pages/Cart.php
@@ -0,0 +1,214 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Filament\User\Pages;
+
+use App\Actions\Store\CreateCheckoutSession;
+use App\Actions\Store\RemoveFromCart;
+use App\Actions\Store\UpdateCartQuantity;
+use App\Models\CartItem;
+use BackedEnum;
+use Filament\Actions\Action;
+use Filament\Forms\Components\TextInput;
+use Filament\Notifications\Notification;
+use Filament\Pages\Page;
+use Filament\Schemas\Components\EmbeddedTable;
+use Filament\Schemas\Schema;
+use Filament\Support\Icons\Heroicon;
+use Filament\Tables\Columns\Summarizers\Sum;
+use Filament\Tables\Columns\TextColumn;
+use Filament\Tables\Concerns\InteractsWithTable;
+use Filament\Tables\Contracts\HasTable;
+use Filament\Tables\Table;
+use InvalidArgumentException;
+use Livewire\Attributes\Url;
+
+final class Cart extends Page implements HasTable
+{
+    use InteractsWithTable {
+        makeTable as makeBaseTable;
+    }
+
+    #[Url(as: 'reordering')]
+    public bool $isTableReordering = false;
+
+    /**
+     * @var array<string, mixed> | null
+     */
+    #[Url(as: 'filters')]
+    public ?array $tableFilters = null;
+
+    #[Url(as: 'grouping')]
+    public ?string $tableGrouping = null;
+
+    /**
+     * @var ?string
+     */
+    #[Url(as: 'search')]
+    public $tableSearch = '';
+
+    #[Url(as: 'sort')]
+    public ?string $tableSort = null;
+
+    protected static ?string $title = 'Cart';
+
+    protected static ?string $slug = 'cart';
+
+    protected static string|BackedEnum|null $navigationIcon = Heroicon::OutlinedShoppingCart;
+
+    protected static ?int $navigationSort = 2;
+
+    public static function getNavigationBadge(): ?string
+    {
+        $count = CartItem::query()
+            ->where('user_id', auth()->id())
+            ->sum('quantity');
+
+        return $count > 0 ? (string) $count : null;
+    }
+
+    public static function getNavigationBadgeColor(): string
+    {
+        return 'primary';
+    }
+
+    public function content(Schema $schema): Schema
+    {
+        return $schema
+            ->components([
+                EmbeddedTable::make(),
+            ]);
+    }
+
+    protected function getHeaderActions(): array
+    {
+        return [
+            Action::make('checkout')
+                ->label('Proceed to Checkout')
+                ->icon(Heroicon::OutlinedCreditCard)
+                ->color('success')
+                ->disabled(fn (): bool => CartItem::query()->where('user_id', auth()->id())->doesntExist())
+                ->requiresConfirmation()
+                ->modalHeading('Proceed to Checkout')
+                ->modalDescription('You will be redirected to Stripe to complete your payment.')
+                ->action(function (): void {
+                    try {
+                        $createCheckout = app(CreateCheckoutSession::class);
+
+                        $successUrl = CheckoutSuccess::getUrl();
+                        $cancelUrl = self::getUrl();
+
+                        $checkoutUrl = $createCheckout->handle(
+                            auth()->user(),
+                            $successUrl,
+                            $cancelUrl,
+                        );
+
+                        $this->redirect($checkoutUrl);
+                    } catch (InvalidArgumentException $e) {
+                        Notification::make()
+                            ->title('Checkout failed')
+                            ->body($e->getMessage())
+                            ->danger()
+                            ->send();
+                    }
+                }),
+        ];
+    }
+
+    protected function makeTable(): Table
+    {
+        return $this->makeBaseTable()
+            ->query(
+                CartItem::query()
+                    ->where('user_id', auth()->id())
+                    ->with('product')
+            )
+            ->columns([
+                TextColumn::make('product.name')
+                    ->label('Product'),
+                TextColumn::make('product.price')
+                    ->label('Unit Price')
+                    ->formatStateUsing(fn (int $state): string => '$'.number_format($state / 100, 2)),
+                TextColumn::make('quantity')
+                    ->label('Qty'),
+                TextColumn::make('line_total')
+                    ->label('Total')
+                    ->state(function (CartItem $record): int {
+                        /** @var \App\Models\Product $product */
+                        $product = $record->product;
+
+                        return $product->price * $record->quantity;
+                    })
+                    ->formatStateUsing(fn (int $state): string => '$'.number_format($state / 100, 2))
+                    ->summarize(
+                        Sum::make()
+                            ->query(fn (\Illuminate\Database\Query\Builder $query): \Illuminate\Database\Query\Builder => $query->selectRaw('SUM(cart_items.quantity * products.price) as aggregate')
+                                ->join('products', 'products.id', '=', 'cart_items.product_id'))
+                            ->formatStateUsing(fn (int $state): string => '$'.number_format($state / 100, 2))
+                            ->label('Total'),
+                    ),
+            ])
+            ->recordActions([
+                Action::make('updateQuantity')
+                    ->label('Update Qty')
+                    ->icon(Heroicon::OutlinedPencilSquare)
+                    ->form([
+                        TextInput::make('quantity')
+                            ->label('Quantity')
+                            ->numeric()
+                            ->minValue(1)
+                            ->required()
+                            ->default(fn (CartItem $record): int => $record->quantity),
+                    ])
+                    ->action(function (CartItem $record, array $data): void {
+                        try {
+                            $updateQuantity = new UpdateCartQuantity;
+                            $updateQuantity->handle(auth()->user(), $record->id, (int) $data['quantity']);
+
+                            Notification::make()
+                                ->title('Quantity updated')
+                                ->success()
+                                ->send();
+                        } catch (InvalidArgumentException $e) {
+                            Notification::make()
+                                ->title('Could not update quantity')
+                                ->body($e->getMessage())
+                                ->danger()
+                                ->send();
+                        }
+                    }),
+                Action::make('remove')
+                    ->label('Remove')
+                    ->icon(Heroicon::OutlinedTrash)
+                    ->color('danger')
+                    ->requiresConfirmation()
+                    ->action(function (CartItem $record): void {
+                        try {
+                            $removeFromCart = new RemoveFromCart;
+                            $removeFromCart->handle(auth()->user(), $record->id);
+
+                            Notification::make()
+                                ->title('Item removed from cart')
+                                ->success()
+                                ->send();
+                        } catch (InvalidArgumentException $e) {
+                            Notification::make()
+                                ->title('Could not remove item')
+                                ->body($e->getMessage())
+                                ->danger()
+                                ->send();
+                        }
+                    }),
+            ])
+            ->emptyStateHeading('Your cart is empty')
+            ->emptyStateDescription('Browse the store to add products to your cart.')
+            ->emptyStateActions([
+                Action::make('browseStore')
+                    ->label('Browse Store')
+                    ->icon(Heroicon::OutlinedShoppingBag)
+                    ->url(Store::getUrl()),
+            ]);
+    }
+}
diff --git a/app/Filament/User/Pages/CheckoutSuccess.php b/app/Filament/User/Pages/CheckoutSuccess.php
new file mode 100644
index 0000000..ca24a43
--- /dev/null
+++ b/app/Filament/User/Pages/CheckoutSuccess.php
@@ -0,0 +1,112 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Filament\User\Pages;
+
+use App\Enums\OrderStatus;
+use App\Models\Order;
+use BackedEnum;
+use Filament\Actions\Action;
+use Filament\Infolists\Components\TextEntry;
+use Filament\Pages\Page;
+use Filament\Schemas\Components\Section;
+use Filament\Schemas\Schema;
+use Filament\Support\Icons\Heroicon;
+
+final class CheckoutSuccess extends Page
+{
+    public ?Order $order = null;
+
+    protected static ?string $title = 'Order Confirmation';
+
+    protected static ?string $slug = 'checkout/success';
+
+    protected static string|BackedEnum|null $navigationIcon = Heroicon::OutlinedCheckCircle;
+
+    protected static bool $shouldRegisterNavigation = false;
+
+    public function mount(): void
+    {
+        $sessionId = request()->query('session_id');
+
+        if ($sessionId !== null) {
+            $this->order = Order::query()
+                ->where('user_id', auth()->id())
+                ->where('stripe_checkout_session_id', $sessionId)
+                ->with('orderItems.product')
+                ->first();
+        }
+    }
+
+    public function content(Schema $schema): Schema
+    {
+        if ($this->order === null) {
+            return $schema
+                ->components([
+                    Section::make('Order Not Found')
+                        ->schema([
+                            TextEntry::make('message')
+                                ->hiddenLabel()
+                                ->state('We could not find your order. Please check your email for confirmation or contact support.'),
+                        ]),
+                ]);
+        }
+
+        $components = [
+            Section::make('Order Details')
+                ->schema([
+                    TextEntry::make('order_number')
+                        ->label('Order Number')
+                        ->state(fn (): string => "#{$this->order->id}"),
+                    TextEntry::make('status')
+                        ->label('Status')
+                        ->state(fn (): string => $this->order->status->getLabel())
+                        ->badge()
+                        ->color(fn (): string => match ($this->order->status) {
+                            OrderStatus::Completed => 'success',
+                            OrderStatus::Pending => 'warning',
+                            OrderStatus::Failed => 'danger',
+                            OrderStatus::Refunded => 'gray',
+                        }),
+                    TextEntry::make('total')
+                        ->label('Total Paid')
+                        ->state(fn (): string => $this->order->formattedTotal()),
+                    TextEntry::make('date')
+                        ->label('Date')
+                        ->state(fn (): string => $this->order->created_at->format('M j, Y g:i A')),
+                ]),
+            Section::make('Items Purchased')
+                ->schema(
+                    $this->order->orderItems->map(
+                        function (\Illuminate\Database\Eloquent\Model $item): TextEntry {
+                            /** @var \App\Models\OrderItem $item */
+                            /** @var \App\Models\Product $product */
+                            $product = $item->product;
+
+                            return TextEntry::make("item_{$item->id}")
+                                ->label($product->name)
+                                ->state(fn (): string => "Qty: {$item->quantity} Ã— {$item->formattedUnitPrice()} = {$item->formattedTotalPrice()}");
+                        }
+                    )->all()
+                ),
+        ];
+
+        return $schema->components($components);
+    }
+
+    protected function getHeaderActions(): array
+    {
+        return [
+            Action::make('viewEnrollments')
+                ->label('View My Classes')
+                ->icon(Heroicon::OutlinedAcademicCap)
+                ->url(MyEnrollments::getUrl()),
+            Action::make('continueShopping')
+                ->label('Continue Shopping')
+                ->icon(Heroicon::OutlinedShoppingBag)
+                ->color('gray')
+                ->url(Store::getUrl()),
+        ];
+    }
+}
diff --git a/app/Filament/User/Pages/Store.php b/app/Filament/User/Pages/Store.php
new file mode 100644
index 0000000..d196b1e
--- /dev/null
+++ b/app/Filament/User/Pages/Store.php
@@ -0,0 +1,130 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Filament\User\Pages;
+
+use App\Actions\Store\AddToCart;
+use App\Models\Course;
+use App\Models\Product;
+use BackedEnum;
+use Filament\Actions\Action;
+use Filament\Notifications\Notification;
+use Filament\Pages\Page;
+use Filament\Schemas\Components\EmbeddedTable;
+use Filament\Schemas\Schema;
+use Filament\Support\Icons\Heroicon;
+use Filament\Tables\Columns\TextColumn;
+use Filament\Tables\Concerns\InteractsWithTable;
+use Filament\Tables\Contracts\HasTable;
+use Filament\Tables\Table;
+use InvalidArgumentException;
+use Livewire\Attributes\Url;
+
+final class Store extends Page implements HasTable
+{
+    use InteractsWithTable {
+        makeTable as makeBaseTable;
+    }
+
+    #[Url(as: 'reordering')]
+    public bool $isTableReordering = false;
+
+    /**
+     * @var array<string, mixed> | null
+     */
+    #[Url(as: 'filters')]
+    public ?array $tableFilters = null;
+
+    #[Url(as: 'grouping')]
+    public ?string $tableGrouping = null;
+
+    /**
+     * @var ?string
+     */
+    #[Url(as: 'search')]
+    public $tableSearch = '';
+
+    #[Url(as: 'sort')]
+    public ?string $tableSort = null;
+
+    protected static ?string $title = 'Store';
+
+    protected static ?string $slug = 'store';
+
+    protected static string|BackedEnum|null $navigationIcon = Heroicon::OutlinedShoppingBag;
+
+    protected static ?int $navigationSort = 1;
+
+    protected ?string $heading = 'Course Store';
+
+    protected ?string $subheading = 'Browse available courses and add them to your cart.';
+
+    public function content(Schema $schema): Schema
+    {
+        return $schema
+            ->components([
+                EmbeddedTable::make(),
+            ]);
+    }
+
+    protected function makeTable(): Table
+    {
+        return $this->makeBaseTable()
+            ->query(
+                Product::query()
+                    ->available()
+                    ->with('productable')
+            )
+            ->columns([
+                TextColumn::make('name')
+                    ->searchable()
+                    ->sortable(),
+                TextColumn::make('description')
+                    ->limit(50)
+                    ->toggleable(),
+                TextColumn::make('price')
+                    ->label('Price')
+                    ->formatStateUsing(fn (int $state): string => '$'.number_format($state / 100, 2))
+                    ->sortable(),
+                TextColumn::make('available_spots')
+                    ->label('Available Spots')
+                    ->state(function (Product $record): string {
+                        if ($record->productable instanceof Course) {
+                            $available = $record->productable->availableCapacity();
+
+                            return $available > 0 ? (string) $available : 'Sold Out';
+                        }
+
+                        return 'N/A';
+                    })
+                    ->badge()
+                    ->color(fn (Product $record): string => $record->productable instanceof Course && $record->productable->availableCapacity() <= 0 ? 'danger' : 'success'),
+            ])
+            ->recordActions([
+                Action::make('addToCart')
+                    ->label('Add to Cart')
+                    ->icon(Heroicon::OutlinedShoppingCart)
+                    ->color('primary')
+                    ->disabled(fn (Product $record): bool => $record->productable instanceof Course && $record->productable->availableCapacity() <= 0)
+                    ->action(function (Product $record): void {
+                        try {
+                            $addToCart = new AddToCart;
+                            $addToCart->handle(auth()->user(), $record);
+
+                            Notification::make()
+                                ->title('Added to cart')
+                                ->body("\"{$record->name}\" has been added to your cart.")
+                                ->success()
+                                ->send();
+                        } catch (InvalidArgumentException $e) {
+                            Notification::make()
+                                ->title('Could not add to cart')
+                                ->body($e->getMessage())
+                                ->danger()
+                                ->send();
+                        }
+                    }),
+            ]);
+    }
+}
diff --git a/app/Http/Controllers/StripeWebhookController.php b/app/Http/Controllers/StripeWebhookController.php
new file mode 100644
index 0000000..3fd0ee7
--- /dev/null
+++ b/app/Http/Controllers/StripeWebhookController.php
@@ -0,0 +1,95 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Http\Controllers;
+
+use App\Actions\Store\CompleteOrder;
+use App\Contracts\StripeServiceContract;
+use App\Enums\OrderStatus;
+use App\Models\Order;
+use Illuminate\Http\JsonResponse;
+use Illuminate\Http\Request;
+use Illuminate\Support\Facades\Log;
+use Stripe\Exception\SignatureVerificationException;
+
+final class StripeWebhookController
+{
+    public function __construct(
+        private readonly StripeServiceContract $stripeService,
+        private readonly CompleteOrder $completeOrder,
+    ) {}
+
+    public function __invoke(Request $request): JsonResponse
+    {
+        $payload = $request->getContent();
+        $signature = $request->header('Stripe-Signature', '');
+
+        try {
+            $event = $this->stripeService->constructWebhookEvent($payload, $signature);
+        } catch (SignatureVerificationException $e) {
+            Log::warning('Stripe webhook signature verification failed.', [
+                'error' => $e->getMessage(),
+            ]);
+
+            return response()->json(['error' => 'Invalid signature'], 400);
+        }
+
+        return match ($event->type) {
+            'checkout.session.completed' => $this->handleCheckoutSessionCompleted($event),
+            'payment_intent.payment_failed' => $this->handlePaymentIntentFailed($event),
+            default => response()->json(['message' => 'Unhandled event type']),
+        };
+    }
+
+    private function handleCheckoutSessionCompleted(\Stripe\Event $event): JsonResponse
+    {
+        $session = $event->data->object;
+        $orderId = $session->metadata->order_id ?? null;
+
+        if ($orderId === null) {
+            Log::warning('Stripe checkout.session.completed missing order_id metadata.', [
+                'session_id' => $session->id,
+            ]);
+
+            return response()->json(['error' => 'Missing order_id'], 400);
+        }
+
+        $order = Order::query()->find($orderId);
+
+        if ($order === null) {
+            Log::warning("Order #{$orderId} not found for checkout session.", [
+                'session_id' => $session->id,
+            ]);
+
+            return response()->json(['error' => 'Order not found'], 404);
+        }
+
+        $order->update([
+            'stripe_payment_intent_id' => $session->payment_intent, // @phpstan-ignore property.notFound
+        ]);
+
+        $this->completeOrder->handle($order);
+
+        return response()->json(['message' => 'Order processed']);
+    }
+
+    private function handlePaymentIntentFailed(\Stripe\Event $event): JsonResponse
+    {
+        $paymentIntent = $event->data->object;
+
+        $order = Order::query()
+            ->where('stripe_payment_intent_id', $paymentIntent->id)
+            ->first();
+
+        if ($order !== null && $order->status === OrderStatus::Pending) {
+            $order->update(['status' => OrderStatus::Failed]);
+
+            Log::info("Order #{$order->id} marked as failed due to payment intent failure.", [
+                'payment_intent_id' => $paymentIntent->id,
+            ]);
+        }
+
+        return response()->json(['message' => 'Payment failure handled']);
+    }
+}
diff --git a/app/Models/CartItem.php b/app/Models/CartItem.php
new file mode 100644
index 0000000..d14612d
--- /dev/null
+++ b/app/Models/CartItem.php
@@ -0,0 +1,32 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Models;
+
+use Illuminate\Database\Eloquent\Factories\HasFactory;
+use Illuminate\Database\Eloquent\Model;
+use Illuminate\Database\Eloquent\Relations\BelongsTo;
+
+final class CartItem extends Model
+{
+    /** @use HasFactory<\Database\Factories\CartItemFactory> */
+    use HasFactory;
+
+    protected $casts = [
+        'id' => 'integer',
+        'user_id' => 'integer',
+        'product_id' => 'integer',
+        'quantity' => 'integer',
+    ];
+
+    public function user(): BelongsTo
+    {
+        return $this->belongsTo(User::class);
+    }
+
+    public function product(): BelongsTo
+    {
+        return $this->belongsTo(Product::class);
+    }
+}
diff --git a/app/Models/Course.php b/app/Models/Course.php
index 3987c5e..3983226 100644
--- a/app/Models/Course.php
+++ b/app/Models/Course.php
@@ -4,7 +4,6 @@
 
 namespace App\Models;
 
-// use App\Actions\Common\EnrollInCourse;
 use Illuminate\Database\Eloquent\Builder;
 use Illuminate\Database\Eloquent\Factories\HasFactory;
 use Illuminate\Database\Eloquent\Model;
@@ -12,15 +11,12 @@
 use Illuminate\Database\Eloquent\Relations\BelongsToMany;
 use Illuminate\Database\Eloquent\Relations\HasMany;
 use Illuminate\Database\Eloquent\Relations\HasOne;
-
-// use Illuminate\Support\Facades\Auth;
-// use Spatie\Tags\HasTags;
+use Illuminate\Database\Eloquent\Relations\MorphOne;
 
 final class Course extends Model
 {
     /** @use HasFactory<\Database\Factories\CourseFactory> */
     use HasFactory;
-    // use HasTags;
 
     protected $casts = [
         'id' => 'integer',
@@ -85,10 +81,10 @@ public function forms(): BelongsToMany
         return $this->belongsToMany(Form::class, 'course_forms');
     }
 
-    // public function product(): BelongsTo
-    // {
-    //     return $this->belongsTo(Product::class);
-    // }
+    public function product(): MorphOne
+    {
+        return $this->morphOne(Product::class, 'productable');
+    }
 
     public function enrollments(): HasMany
     {
@@ -105,17 +101,24 @@ public function students(): BelongsToMany
         return $this->belongsToMany(Student::class, 'enrollments');
     }
 
-    // public function completeItemSale(OrderItem $item): void
-    // {
-    //     $enroll = new EnrollInCourse();
-    //     for($i = 0; $i < $item->quantity; $i++) {
-    //         // $enroll->handle($item->product->sellable, Auth::id());
-    //         $enroll->handle($this, Auth::id());
-    //     }
-    // }
-
-    // public function saleTypeGroupAction(Order $order): void
-    // {
-    //     // send email detailing assigning a student to classes and completing medical waivers
-    // }
+    /**
+     * Get the number of available enrollment spots remaining.
+     */
+    public function availableCapacity(): int
+    {
+        return $this->capacity - $this->enrollments()->count();
+    }
+
+    /**
+     * Scope to only include courses with available capacity.
+     */
+    public function scopeAvailable(Builder $query): void
+    {
+        $query->where(
+            'capacity',
+            '>',
+            Enrollment::selectRaw('count(*)')
+                ->whereColumn('enrollments.course_id', 'courses.id')
+        );
+    }
 }
diff --git a/app/Models/Enrollment.php b/app/Models/Enrollment.php
index ae374e3..994eb02 100644
--- a/app/Models/Enrollment.php
+++ b/app/Models/Enrollment.php
@@ -7,11 +7,15 @@
 use Carbon\Carbon;
 use Illuminate\Database\Eloquent\Attributes\Scope;
 use Illuminate\Database\Eloquent\Builder;
+use Illuminate\Database\Eloquent\Factories\HasFactory;
 use Illuminate\Database\Eloquent\Model;
 use Illuminate\Database\Eloquent\Relations\BelongsTo;
 
 final class Enrollment extends Model
 {
+    /** @use HasFactory<\Database\Factories\EnrollmentFactory> */
+    use HasFactory;
+
     public function course(): BelongsTo
     {
         return $this->belongsTo(Course::class);
@@ -36,7 +40,7 @@ protected function open(Builder $query): void
     #[Scope]
     protected function active(Builder $query, ?Carbon $date = null): void
     {
-        if (!$date instanceof Carbon) {
+        if (! $date instanceof Carbon) {
             $date = Carbon::now();
         }
 
@@ -51,7 +55,7 @@ protected function active(Builder $query, ?Carbon $date = null): void
     #[Scope]
     protected function future(Builder $query, ?Carbon $date = null): void
     {
-        if (!$date instanceof Carbon) {
+        if (! $date instanceof Carbon) {
             $date = Carbon::now();
         }
 
@@ -62,7 +66,7 @@ protected function future(Builder $query, ?Carbon $date = null): void
     #[Scope]
     protected function past(Builder $query, ?Carbon $date = null): void
     {
-        if (!$date instanceof Carbon) {
+        if (! $date instanceof Carbon) {
             $date = Carbon::now();
         }
 
diff --git a/app/Models/Order.php b/app/Models/Order.php
new file mode 100644
index 0000000..a34094d
--- /dev/null
+++ b/app/Models/Order.php
@@ -0,0 +1,51 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Models;
+
+use App\Enums\OrderStatus;
+use Illuminate\Database\Eloquent\Factories\HasFactory;
+use Illuminate\Database\Eloquent\Model;
+use Illuminate\Database\Eloquent\Relations\BelongsTo;
+use Illuminate\Database\Eloquent\Relations\HasMany;
+
+final class Order extends Model
+{
+    /** @use HasFactory<\Database\Factories\OrderFactory> */
+    use HasFactory;
+
+    protected $casts = [
+        'id' => 'integer',
+        'user_id' => 'integer',
+        'status' => OrderStatus::class,
+        'subtotal' => 'integer',
+        'total' => 'integer',
+    ];
+
+    public function user(): BelongsTo
+    {
+        return $this->belongsTo(User::class);
+    }
+
+    public function orderItems(): HasMany
+    {
+        return $this->hasMany(OrderItem::class);
+    }
+
+    /**
+     * Get the formatted subtotal in dollars.
+     */
+    public function formattedSubtotal(): string
+    {
+        return '$'.number_format($this->subtotal / 100, 2);
+    }
+
+    /**
+     * Get the formatted total in dollars.
+     */
+    public function formattedTotal(): string
+    {
+        return '$'.number_format($this->total / 100, 2);
+    }
+}
diff --git a/app/Models/OrderItem.php b/app/Models/OrderItem.php
new file mode 100644
index 0000000..ff827a8
--- /dev/null
+++ b/app/Models/OrderItem.php
@@ -0,0 +1,50 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Models;
+
+use Illuminate\Database\Eloquent\Factories\HasFactory;
+use Illuminate\Database\Eloquent\Model;
+use Illuminate\Database\Eloquent\Relations\BelongsTo;
+
+final class OrderItem extends Model
+{
+    /** @use HasFactory<\Database\Factories\OrderItemFactory> */
+    use HasFactory;
+
+    protected $casts = [
+        'id' => 'integer',
+        'order_id' => 'integer',
+        'product_id' => 'integer',
+        'quantity' => 'integer',
+        'unit_price' => 'integer',
+        'total_price' => 'integer',
+    ];
+
+    public function order(): BelongsTo
+    {
+        return $this->belongsTo(Order::class);
+    }
+
+    public function product(): BelongsTo
+    {
+        return $this->belongsTo(Product::class);
+    }
+
+    /**
+     * Get the formatted unit price in dollars.
+     */
+    public function formattedUnitPrice(): string
+    {
+        return '$'.number_format($this->unit_price / 100, 2);
+    }
+
+    /**
+     * Get the formatted total price in dollars.
+     */
+    public function formattedTotalPrice(): string
+    {
+        return '$'.number_format($this->total_price / 100, 2);
+    }
+}
diff --git a/app/Models/Product.php b/app/Models/Product.php
new file mode 100644
index 0000000..0a33d9e
--- /dev/null
+++ b/app/Models/Product.php
@@ -0,0 +1,63 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Models;
+
+use Illuminate\Database\Eloquent\Builder;
+use Illuminate\Database\Eloquent\Factories\HasFactory;
+use Illuminate\Database\Eloquent\Model;
+use Illuminate\Database\Eloquent\Relations\BelongsTo;
+use Illuminate\Database\Eloquent\Relations\HasMany;
+use Illuminate\Database\Eloquent\Relations\MorphTo;
+
+final class Product extends Model
+{
+    /** @use HasFactory<\Database\Factories\ProductFactory> */
+    use HasFactory;
+
+    protected $casts = [
+        'id' => 'integer',
+        'price' => 'integer',
+        'is_active' => 'boolean',
+        'requires_course_id' => 'integer',
+    ];
+
+    public function productable(): MorphTo
+    {
+        return $this->morphTo();
+    }
+
+    public function requiresCourse(): BelongsTo
+    {
+        return $this->belongsTo(Course::class, 'requires_course_id');
+    }
+
+    public function cartItems(): HasMany
+    {
+        return $this->hasMany(CartItem::class);
+    }
+
+    public function orderItems(): HasMany
+    {
+        return $this->hasMany(OrderItem::class);
+    }
+
+    /**
+     * Scope to only include active products that are available for purchase.
+     * For Course products, this also checks that there is remaining capacity.
+     */
+    public function scopeAvailable(Builder $query): void
+    {
+        $query->where('is_active', true)
+            ->where('price', '>', 0);
+    }
+
+    /**
+     * Get the formatted price in dollars.
+     */
+    public function formattedPrice(): string
+    {
+        return '$'.number_format($this->price / 100, 2);
+    }
+}
diff --git a/app/Models/User.php b/app/Models/User.php
index af440fb..06f67a7 100644
--- a/app/Models/User.php
+++ b/app/Models/User.php
@@ -85,6 +85,16 @@ public function purchasedCourses(): BelongsToMany
         return $this->belongsToMany(Course::class, 'enrollments');
     }
 
+    public function orders(): HasMany
+    {
+        return $this->hasMany(Order::class);
+    }
+
+    public function cartItems(): HasMany
+    {
+        return $this->hasMany(CartItem::class);
+    }
+
     /**
      * Get the attributes that should be cast.
      *
diff --git a/app/Providers/AppServiceProvider.php b/app/Providers/AppServiceProvider.php
index f866f8f..78322aa 100644
--- a/app/Providers/AppServiceProvider.php
+++ b/app/Providers/AppServiceProvider.php
@@ -4,19 +4,25 @@
 
 namespace App\Providers;
 
+use App\Contracts\StripeServiceContract;
+use App\Services\StripeService;
 use BezhanSalleh\PanelSwitch\PanelSwitch;
 use Filament\Actions\Action;
 use Filament\Actions\CreateAction;
 use Filament\Actions\EditAction;
 use Filament\Tables\Table;
-use Filament\View\PanelsRenderHook;
 use Illuminate\Support\ServiceProvider;
+use Stripe\StripeClient;
 
 final class AppServiceProvider extends ServiceProvider
 {
     public function register(): void
     {
-        //
+        $this->app->singleton(StripeServiceContract::class, function (): StripeService {
+            return new StripeService(
+                new StripeClient(config('services.stripe.secret')),
+            );
+        });
     }
 
     public function boot(): void
diff --git a/app/Services/StripeService.php b/app/Services/StripeService.php
new file mode 100644
index 0000000..3faa7be
--- /dev/null
+++ b/app/Services/StripeService.php
@@ -0,0 +1,87 @@
+<?php
+
+declare(strict_types=1);
+
+namespace App\Services;
+
+use App\Contracts\StripeServiceContract;
+use App\Models\User;
+use Stripe\Checkout\Session as CheckoutSession;
+use Stripe\Customer;
+use Stripe\Event;
+use Stripe\Exception\SignatureVerificationException;
+use Stripe\Refund;
+use Stripe\StripeClient;
+use Stripe\Webhook;
+
+final readonly class StripeService implements StripeServiceContract
+{
+    public function __construct(
+        private StripeClient $client,
+    ) {}
+
+    public function createOrGetCustomer(User $user): Customer
+    {
+        if ($user->stripe_id !== null) {
+            return $this->client->customers->retrieve($user->stripe_id);
+        }
+
+        $customer = $this->client->customers->create([
+            'email' => $user->email,
+            'name' => $user->full_name, // @phpstan-ignore property.notFound
+            'metadata' => [
+                'user_id' => (string) $user->id,
+            ],
+        ]);
+
+        $user->update(['stripe_id' => $customer->id]);
+
+        return $customer;
+    }
+
+    /**
+     * @param  array<int, array{price_data: array{currency: string, product_data: array{name: string}, unit_amount: int}, quantity: int}>  $lineItems
+     * @param  array<string, string>  $metadata
+     */
+    public function createCheckoutSession(
+        User $user,
+        array $lineItems,
+        string $successUrl,
+        string $cancelUrl,
+        array $metadata = [],
+    ): CheckoutSession {
+        $customer = $this->createOrGetCustomer($user);
+
+        return $this->client->checkout->sessions->create([
+            'customer' => $customer->id,
+            'line_items' => $lineItems,
+            'mode' => 'payment',
+            'success_url' => $successUrl,
+            'cancel_url' => $cancelUrl,
+            'metadata' => $metadata,
+        ]);
+    }
+
+    /**
+     * @throws SignatureVerificationException
+     */
+    public function constructWebhookEvent(string $payload, string $signature): Event
+    {
+        return Webhook::constructEvent(
+            $payload,
+            $signature,
+            config('services.stripe.webhook_secret'),
+        );
+    }
+
+    public function refundPaymentIntent(string $paymentIntentId, ?int $amount = null): Refund
+    {
+        $params = ['payment_intent' => $paymentIntentId];
+
+        if ($amount !== null) {
+            $params['amount'] = $amount;
+        }
+
+        return $this->client->refunds->create($params);
+    }
+}
diff --git a/bootstrap/app.php b/bootstrap/app.php
index 32c6218..7dfaf08 100644
--- a/bootstrap/app.php
+++ b/bootstrap/app.php
@@ -13,7 +13,9 @@
         health: '/up',
     )
     ->withMiddleware(function (Middleware $middleware): void {
-        //
+        $middleware->validateCsrfTokens(except: [
+            'stripe/webhook',
+        ]);
     })
     ->withExceptions(function (Exceptions $exceptions): void {
         //
diff --git a/composer.json b/composer.json
index c3bd5b4..0edafd6 100644
--- a/composer.json
+++ b/composer.json
@@ -19,7 +19,8 @@
         "laravel/framework": "^12.0",
         "laravel/tinker": "^2.10.1",
         "nunomaduro/essentials": "^0.1",
-        "saade/filament-fullcalendar": "^4.0"
+        "saade/filament-fullcalendar": "^4.0",
+        "stripe/stripe-php": "^19.4"
     },
     "require-dev": {
         "barryvdh/laravel-debugbar": "^3.15",
diff --git a/composer.lock b/composer.lock
index f282168..f0c3891 100644
--- a/composer.lock
+++ b/composer.lock
@@ -4,7 +4,7 @@
         "Read more about it at https://getcomposer.org/doc/01-basic-usage.md#installing-dependencies",
         "This file is @generated automatically"
     ],
-    "content-hash": "fa95d3def541406dc50d48783962a7de",
+    "content-hash": "0af52158e1787685e5d5d2b24dc45b6e",
     "packages": [
         {
             "name": "anourvalar/eloquent-serialize",
@@ -5871,6 +5871,65 @@
             ],
             "time": "2026-02-01T09:30:04+00:00"
         },
+        {
+            "name": "stripe/stripe-php",
+            "version": "v19.4.0",
+            "source": {
+                "type": "git",
+                "url": "https://github.com/stripe/stripe-php.git",
+                "reference": "a8c9db819f86ec47e603b92f9be99661e6a62cf4"
+            },
+            "dist": {
+                "type": "zip",
+                "url": "https://api.github.com/repos/stripe/stripe-php/zipball/a8c9db819f86ec47e603b92f9be99661e6a62cf4",
+                "reference": "a8c9db819f86ec47e603b92f9be99661e6a62cf4",
+                "shasum": ""
+            },
+            "require": {
+                "ext-curl": "*",
+                "ext-json": "*",
+                "ext-mbstring": "*",
+                "php": ">=5.6.0"
+            },
+            "require-dev": {
+                "friendsofphp/php-cs-fixer": "3.72.0",
+                "phpstan/phpstan": "^1.2",
+                "phpunit/phpunit": "^5.7 || ^9.0"
+            },
+            "type": "library",
+            "extra": {
+                "branch-alias": {
+                    "dev-master": "2.0-dev"
+                }
+            },
+            "autoload": {
+                "psr-4": {
+                    "Stripe\\": "lib/"
+                }
+            },
+            "notification-url": "https://packagist.org/downloads/",
+            "license": [
+                "MIT"
+            ],
+            "authors": [
+                {
+                    "name": "Stripe and contributors",
+                    "homepage": "https://github.com/stripe/stripe-php/contributors"
+                }
+            ],
+            "description": "Stripe PHP Library",
+            "homepage": "https://stripe.com/",
+            "keywords": [
+                "api",
+                "payment processing",
+                "stripe"
+            ],
+            "support": {
+                "issues": "https://github.com/stripe/stripe-php/issues",
+                "source": "https://github.com/stripe/stripe-php/tree/v19.4.0"
+            },
+            "time": "2026-02-25T17:46:20+00:00"
+        },
         {
             "name": "symfony/clock",
             "version": "v8.0.0",
@@ -14290,5 +14349,5 @@
         "php": "^8.3"
     },
     "platform-dev": {},
-    "plugin-api-version": "2.9.0"
+    "plugin-api-version": "2.6.0"
 }
diff --git a/config/services.php b/config/services.php
new file mode 100644
index 0000000..d2de278
--- /dev/null
+++ b/config/services.php
@@ -0,0 +1,13 @@
+<?php
+
+declare(strict_types=1);
+
+return [
+
+    'stripe' => [
+        'key' => env('STRIPE_KEY'),
+        'secret' => env('STRIPE_SECRET'),
+        'webhook_secret' => env('STRIPE_WEBHOOK_SECRET'),
+    ],
+
+];
diff --git a/database/factories/CartItemFactory.php b/database/factories/CartItemFactory.php
new file mode 100644
index 0000000..c458806
--- /dev/null
+++ b/database/factories/CartItemFactory.php
@@ -0,0 +1,30 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Database\Factories;
+
+use App\Models\CartItem;
+use App\Models\Product;
+use App\Models\User;
+use Illuminate\Database\Eloquent\Factories\Factory;
+
+/**
+ * @extends Factory<CartItem>
+ */
+final class CartItemFactory extends Factory
+{
+    /**
+     * Define the model's default state.
+     *
+     * @return array<string, mixed>
+     */
+    public function definition(): array
+    {
+        return [
+            'user_id' => User::factory(),
+            'product_id' => Product::factory(),
+            'quantity' => 1,
+        ];
+    }
+}
diff --git a/database/factories/EnrollmentFactory.php b/database/factories/EnrollmentFactory.php
new file mode 100644
index 0000000..7d3bddb
--- /dev/null
+++ b/database/factories/EnrollmentFactory.php
@@ -0,0 +1,41 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Database\Factories;
+
+use App\Models\Course;
+use App\Models\Enrollment;
+use App\Models\Student;
+use App\Models\User;
+use Illuminate\Database\Eloquent\Factories\Factory;
+
+/**
+ * @extends Factory<Enrollment>
+ */
+final class EnrollmentFactory extends Factory
+{
+    /**
+     * Define the model's default state.
+     *
+     * @return array<string, mixed>
+     */
+    public function definition(): array
+    {
+        return [
+            'course_id' => Course::factory(),
+            'user_id' => User::factory(),
+            'student_id' => null,
+        ];
+    }
+
+    /**
+     * Create an enrollment with a student assigned.
+     */
+    public function withStudent(?Student $student = null): static
+    {
+        return $this->state(fn (array $attributes): array => [
+            'student_id' => $student?->id ?? Student::factory(),
+        ]);
+    }
+}
diff --git a/database/factories/OrderFactory.php b/database/factories/OrderFactory.php
new file mode 100644
index 0000000..b205ea3
--- /dev/null
+++ b/database/factories/OrderFactory.php
@@ -0,0 +1,57 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Database\Factories;
+
+use App\Enums\OrderStatus;
+use App\Models\Order;
+use App\Models\User;
+use Illuminate\Database\Eloquent\Factories\Factory;
+
+/**
+ * @extends Factory<Order>
+ */
+final class OrderFactory extends Factory
+{
+    /**
+     * Define the model's default state.
+     *
+     * @return array<string, mixed>
+     */
+    public function definition(): array
+    {
+        $subtotal = fake()->randomElement([2500, 5000, 7500, 10000, 15000]);
+
+        return [
+            'user_id' => User::factory(),
+            'status' => OrderStatus::Pending,
+            'subtotal' => $subtotal,
+            'total' => $subtotal,
+            'stripe_checkout_session_id' => null,
+            'stripe_payment_intent_id' => null,
+        ];
+    }
+
+    /**
+     * Mark order as completed.
+     */
+    public function completed(): static
+    {
+        return $this->state(fn (array $attributes): array => [
+            'status' => OrderStatus::Completed,
+            'stripe_checkout_session_id' => 'cs_test_'.fake()->uuid(),
+            'stripe_payment_intent_id' => 'pi_test_'.fake()->uuid(),
+        ]);
+    }
+
+    /**
+     * Mark order as failed.
+     */
+    public function failed(): static
+    {
+        return $this->state(fn (array $attributes): array => [
+            'status' => OrderStatus::Failed,
+        ]);
+    }
+}
diff --git a/database/factories/OrderItemFactory.php b/database/factories/OrderItemFactory.php
new file mode 100644
index 0000000..211d783
--- /dev/null
+++ b/database/factories/OrderItemFactory.php
@@ -0,0 +1,35 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Database\Factories;
+
+use App\Models\Order;
+use App\Models\OrderItem;
+use App\Models\Product;
+use Illuminate\Database\Eloquent\Factories\Factory;
+
+/**
+ * @extends Factory<OrderItem>
+ */
+final class OrderItemFactory extends Factory
+{
+    /**
+     * Define the model's default state.
+     *
+     * @return array<string, mixed>
+     */
+    public function definition(): array
+    {
+        $unitPrice = fake()->randomElement([2500, 5000, 7500, 10000]);
+        $quantity = fake()->numberBetween(1, 3);
+
+        return [
+            'order_id' => Order::factory(),
+            'product_id' => Product::factory(),
+            'quantity' => $quantity,
+            'unit_price' => $unitPrice,
+            'total_price' => $unitPrice * $quantity,
+        ];
+    }
+}
diff --git a/database/factories/ProductFactory.php b/database/factories/ProductFactory.php
new file mode 100644
index 0000000..9566b89
--- /dev/null
+++ b/database/factories/ProductFactory.php
@@ -0,0 +1,59 @@
+<?php
+
+declare(strict_types=1);
+
+namespace Database\Factories;
+
+use App\Models\Course;
+use App\Models\Product;
+use Illuminate\Database\Eloquent\Factories\Factory;
+
+/**
+ * @extends Factory<Product>
+ */
+final class ProductFactory extends Factory
+{
+    /**
+     * Define the model's default state.
+     *
+     * @return array<string, mixed>
+     */
+    public function definition(): array
+    {
+        return [
+            'name' => fake()->words(3, true),
+            'description' => fake()->sentence(),
+            'price' => fake()->randomElement([2500, 5000, 7500, 10000, 12500, 15000]),
+            'is_active' => true,
+            'requires_course_id' => null,
+            'productable_type' => null,
+            'productable_id' => null,
+        ];
+    }
+
+    /**
+     * Create a product linked to a Course.
+     */
+    public function forCourse(?Course $course = null): static
+    {
+        return $this->state(function (array $attributes) use ($course): array {
+            $course ??= Course::factory()->create();
+
+            return [
+                'name' => $course->name,
+                'productable_type' => Course::class,
+                'productable_id' => $course->id,
+            ];
+        });
+    }
+
+    /**
+     * Mark the product as inactive.
+     */
+    public function inactive(): static
+    {
+        return $this->state(fn (array $attributes): array => [
+            'is_active' => false,
+        ]);
+    }
+}
diff --git a/database/migrations/2026_02_26_000001_add_stripe_id_to_users_table.php b/database/migrations/2026_02_26_000001_add_stripe_id_to_users_table.php
new file mode 100644
index 0000000..9ff07c5
--- /dev/null
+++ b/database/migrations/2026_02_26_000001_add_stripe_id_to_users_table.php
@@ -0,0 +1,17 @@
+<?php
+
+declare(strict_types=1);
+
+use Illuminate\Database\Migrations\Migration;
+use Illuminate\Database\Schema\Blueprint;
+use Illuminate\Support\Facades\Schema;
+
+return new class() extends Migration
+{
+    public function up(): void
+    {
+        Schema::table('users', function (Blueprint $table) {
+            $table->string('stripe_id')->nullable()->unique()->after('remember_token');
+        });
+    }
+};
diff --git a/database/migrations/2026_02_26_000002_create_products_table.php b/database/migrations/2026_02_26_000002_create_products_table.php
new file mode 100644
index 0000000..5b1d446
--- /dev/null
+++ b/database/migrations/2026_02_26_000002_create_products_table.php
@@ -0,0 +1,26 @@
+<?php
+
+declare(strict_types=1);
+
+use Illuminate\Database\Migrations\Migration;
+use Illuminate\Database\Schema\Blueprint;
+use Illuminate\Support\Facades\Schema;
+
+return new class() extends Migration
+{
+    public function up(): void
+    {
+        Schema::create('products', function (Blueprint $table) {
+            $table->id();
+            $table->string('name');
+            $table->text('description')->nullable();
+            $table->unsignedInteger('price')->default(0);
+            $table->boolean('is_active')->default(true);
+            $table->foreignId('requires_course_id')->nullable()->constrained('courses')->nullOnDelete();
+            $table->nullableMorphs('productable');
+            $table->timestamps();
+
+            $table->unique(['productable_type', 'productable_id']);
+        });
+    }
+};
diff --git a/database/migrations/2026_02_26_000003_create_cart_items_table.php b/database/migrations/2026_02_26_000003_create_cart_items_table.php
new file mode 100644
index 0000000..8bd804b
--- /dev/null
+++ b/database/migrations/2026_02_26_000003_create_cart_items_table.php
@@ -0,0 +1,23 @@
+<?php
+
+declare(strict_types=1);
+
+use Illuminate\Database\Migrations\Migration;
+use Illuminate\Database\Schema\Blueprint;
+use Illuminate\Support\Facades\Schema;
+
+return new class() extends Migration
+{
+    public function up(): void
+    {
+        Schema::create('cart_items', function (Blueprint $table) {
+            $table->id();
+            $table->foreignId('user_id')->constrained()->cascadeOnDelete();
+            $table->foreignId('product_id')->constrained()->cascadeOnDelete();
+            $table->unsignedSmallInteger('quantity')->default(1);
+            $table->timestamps();
+
+            $table->unique(['user_id', 'product_id']);
+        });
+    }
+};
diff --git a/database/migrations/2026_02_26_000004_create_orders_table.php b/database/migrations/2026_02_26_000004_create_orders_table.php
new file mode 100644
index 0000000..e93b2d8
--- /dev/null
+++ b/database/migrations/2026_02_26_000004_create_orders_table.php
@@ -0,0 +1,24 @@
+<?php
+
+declare(strict_types=1);
+
+use Illuminate\Database\Migrations\Migration;
+use Illuminate\Database\Schema\Blueprint;
+use Illuminate\Support\Facades\Schema;
+
+return new class() extends Migration
+{
+    public function up(): void
+    {
+        Schema::create('orders', function (Blueprint $table) {
+            $table->id();
+            $table->foreignId('user_id')->constrained();
+            $table->string('status')->default('Pending');
+            $table->unsignedInteger('subtotal');
+            $table->unsignedInteger('total');
+            $table->string('stripe_checkout_session_id')->nullable();
+            $table->string('stripe_payment_intent_id')->nullable();
+            $table->timestamps();
+        });
+    }
+};
diff --git a/database/migrations/2026_02_26_000005_create_order_items_table.php b/database/migrations/2026_02_26_000005_create_order_items_table.php
new file mode 100644
index 0000000..d5c2412
--- /dev/null
+++ b/database/migrations/2026_02_26_000005_create_order_items_table.php
@@ -0,0 +1,23 @@
+<?php
+
+declare(strict_types=1);
+
+use Illuminate\Database\Migrations\Migration;
+use Illuminate\Database\Schema\Blueprint;
+use Illuminate\Support\Facades\Schema;
+
+return new class() extends Migration
+{
+    public function up(): void
+    {
+        Schema::create('order_items', function (Blueprint $table) {
+            $table->id();
+            $table->foreignId('order_id')->constrained()->cascadeOnDelete();
+            $table->foreignId('product_id')->constrained();
+            $table->unsignedSmallInteger('quantity');
+            $table->unsignedInteger('unit_price');
+            $table->unsignedInteger('total_price');
+            $table->timestamps();
+        });
+    }
+};
diff --git a/database/seeders/DatabaseSeeder.php b/database/seeders/DatabaseSeeder.php
index 784da42..fbdf79a 100644
--- a/database/seeders/DatabaseSeeder.php
+++ b/database/seeders/DatabaseSeeder.php
@@ -7,6 +7,7 @@
 use App\Enums\FormTypes;
 use App\Models\Course;
 use App\Models\Form;
+use App\Models\Product;
 use App\Models\User;
 use Database\Factories\CalendarFactory;
 // use Illuminate\Database\Console\Seeds\WithoutModelEvents;
@@ -44,7 +45,12 @@ private function seedDevData(): void
             'password' => bcrypt(config('app.default_user.password')),
         ]);
 
-        Course::factory(10)->create();
+        $courses = Course::factory(10)->create();
+
+        // Create a Product for each Course
+        $courses->each(function (Course $course): void {
+            Product::factory()->forCourse($course)->create();
+        });
 
         User::factory()
             ->count(10)
diff --git a/routes/web.php b/routes/web.php
index 00cc79f..c5bb16e 100644
--- a/routes/web.php
+++ b/routes/web.php
@@ -2,6 +2,10 @@
 
 declare(strict_types=1);
 
+use App\Http\Controllers\StripeWebhookController;
 use Illuminate\Support\Facades\Route;
 
 Route::view('/', 'welcome');
+
+Route::post('/stripe/webhook', StripeWebhookController::class)
+    ->name('stripe.webhook');
diff --git a/tests/Feature/Actions/Store/CartActionsTest.php b/tests/Feature/Actions/Store/CartActionsTest.php
new file mode 100644
index 0000000..6acf8f4
--- /dev/null
+++ b/tests/Feature/Actions/Store/CartActionsTest.php
@@ -0,0 +1,148 @@
+<?php
+
+declare(strict_types=1);
+
+use App\Actions\Store\AddToCart;
+use App\Actions\Store\RemoveFromCart;
+use App\Actions\Store\UpdateCartQuantity;
+use App\Models\CartItem;
+use App\Models\Course;
+use App\Models\Enrollment;
+use App\Models\Product;
+use App\Models\User;
+
+use function Pest\Laravel\assertDatabaseHas;
+use function Pest\Laravel\assertDatabaseMissing;
+
+beforeEach(function () {
+    $this->user = User::factory()->create();
+    $this->course = Course::factory()->create(['capacity' => 5]);
+    $this->product = Product::factory()->forCourse($this->course)->create(['price' => 5000]);
+});
+
+it('can add a product to the cart', function () {
+    $action = new AddToCart;
+    $cartItem = $action->handle($this->user, $this->product);
+
+    expect($cartItem)->toBeInstanceOf(CartItem::class);
+
+    assertDatabaseHas(CartItem::class, [
+        'user_id' => $this->user->id,
+        'product_id' => $this->product->id,
+        'quantity' => 1,
+    ]);
+});
+
+it('increments quantity when adding the same product again', function () {
+    $action = new AddToCart;
+    $action->handle($this->user, $this->product);
+    $action->handle($this->user, $this->product);
+
+    expect(CartItem::query()->where('user_id', $this->user->id)->count())->toBe(1);
+
+    $cartItem = CartItem::query()
+        ->where('user_id', $this->user->id)
+        ->where('product_id', $this->product->id)
+        ->first();
+
+    expect($cartItem->quantity)->toBe(2);
+});
+
+it('rejects adding to cart when course is at capacity', function () {
+    // Fill all spots
+    for ($i = 0; $i < 5; $i++) {
+        Enrollment::factory()->create(['course_id' => $this->course->id]);
+    }
+
+    $action = new AddToCart;
+    $action->handle($this->user, $this->product);
+})->throws(InvalidArgumentException::class, 'Only 0 spot(s) remaining for this course.');
+
+it('rejects adding to cart when quantity exceeds available capacity', function () {
+    // Fill 4 of 5 spots
+    for ($i = 0; $i < 4; $i++) {
+        Enrollment::factory()->create(['course_id' => $this->course->id]);
+    }
+
+    $action = new AddToCart;
+    $action->handle($this->user, $this->product);
+    $action->handle($this->user, $this->product); // This should fail - 1 available but already have 1 in cart
+})->throws(InvalidArgumentException::class, 'Only 1 spot(s) remaining for this course.');
+
+it('rejects adding an inactive product to the cart', function () {
+    $this->product->update(['is_active' => false]);
+
+    $action = new AddToCart;
+    $action->handle($this->user, $this->product->refresh());
+})->throws(InvalidArgumentException::class, 'This product is not available for purchase.');
+
+it('rejects adding a product with no price', function () {
+    $this->product->update(['price' => 0]);
+
+    $action = new AddToCart;
+    $action->handle($this->user, $this->product->refresh());
+})->throws(InvalidArgumentException::class, 'This product does not have a valid price.');
+
+it('can remove an item from the cart', function () {
+    $cartItem = CartItem::factory()->create([
+        'user_id' => $this->user->id,
+        'product_id' => $this->product->id,
+    ]);
+
+    $action = new RemoveFromCart;
+    $action->handle($this->user, $cartItem->id);
+
+    assertDatabaseMissing(CartItem::class, [
+        'id' => $cartItem->id,
+    ]);
+});
+
+it('rejects removing a cart item that does not belong to the user', function () {
+    $otherUser = User::factory()->create();
+    $cartItem = CartItem::factory()->create([
+        'user_id' => $otherUser->id,
+        'product_id' => $this->product->id,
+    ]);
+
+    $action = new RemoveFromCart;
+    $action->handle($this->user, $cartItem->id);
+})->throws(InvalidArgumentException::class, 'Cart item not found.');
+
+it('can update cart item quantity', function () {
+    $cartItem = CartItem::factory()->create([
+        'user_id' => $this->user->id,
+        'product_id' => $this->product->id,
+        'quantity' => 1,
+    ]);
+
+    $action = new UpdateCartQuantity;
+    $updated = $action->handle($this->user, $cartItem->id, 3);
+
+    expect($updated->quantity)->toBe(3);
+});
+
+it('rejects updating quantity beyond course capacity', function () {
+    // 3 spots already taken
+    for ($i = 0; $i < 3; $i++) {
+        Enrollment::factory()->create(['course_id' => $this->course->id]);
+    }
+
+    $cartItem = CartItem::factory()->create([
+        'user_id' => $this->user->id,
+        'product_id' => $this->product->id,
+        'quantity' => 1,
+    ]);
+
+    $action = new UpdateCartQuantity;
+    $action->handle($this->user, $cartItem->id, 5); // Only 2 available
+})->throws(InvalidArgumentException::class, 'Only 2 spot(s) remaining for this course.');
+
+it('rejects updating quantity to less than 1', function () {
+    $cartItem = CartItem::factory()->create([
+        'user_id' => $this->user->id,
+        'product_id' => $this->product->id,
+    ]);
+
+    $action = new UpdateCartQuantity;
+    $action->handle($this->user, $cartItem->id, 0);
+})->throws(InvalidArgumentException::class, 'Quantity must be at least 1.');
diff --git a/tests/Feature/Actions/Store/CheckoutTest.php b/tests/Feature/Actions/Store/CheckoutTest.php
new file mode 100644
index 0000000..0bd0d09
--- /dev/null
+++ b/tests/Feature/Actions/Store/CheckoutTest.php
@@ -0,0 +1,125 @@
+<?php
+
+declare(strict_types=1);
+
+use App\Actions\Store\CreateCheckoutSession;
+use App\Contracts\StripeServiceContract;
+use App\Enums\OrderStatus;
+use App\Models\CartItem;
+use App\Models\Course;
+use App\Models\Enrollment;
+use App\Models\Order;
+use App\Models\OrderItem;
+use App\Models\Product;
+use App\Models\User;
+use Stripe\Checkout\Session as StripeSession;
+
+beforeEach(function () {
+    $this->user = User::factory()->create();
+    $this->course = Course::factory()->create(['capacity' => 5]);
+    $this->product = Product::factory()->forCourse($this->course)->create(['price' => 5000]);
+});
+
+it('creates an order and returns a stripe checkout url', function () {
+    CartItem::factory()->create([
+        'user_id' => $this->user->id,
+        'product_id' => $this->product->id,
+        'quantity' => 2,
+    ]);
+
+    $mockSession = StripeSession::constructFrom([
+        'id' => 'cs_test_123',
+        'url' => 'https://checkout.stripe.com/test',
+    ]);
+
+    $mockStripeService = Mockery::mock(StripeServiceContract::class);
+    $mockStripeService->shouldReceive('createCheckoutSession')
+        ->once()
+        ->andReturn($mockSession);
+
+    $this->app->instance(StripeServiceContract::class, $mockStripeService);
+
+    $action = app(CreateCheckoutSession::class);
+    $url = $action->handle($this->user, 'https://example.com/success', 'https://example.com/cancel');
+
+    expect($url)->toBe('https://checkout.stripe.com/test');
+
+    // Verify order was created
+    $order = Order::query()->where('user_id', $this->user->id)->first();
+    expect($order)->not->toBeNull()
+        ->and($order->status)->toBe(OrderStatus::Pending)
+        ->and($order->subtotal)->toBe(10000) // 2 * 5000
+        ->and($order->total)->toBe(10000)
+        ->and($order->stripe_checkout_session_id)->toBe('cs_test_123');
+
+    // Verify order items
+    $orderItems = OrderItem::query()->where('order_id', $order->id)->get();
+    expect($orderItems)->toHaveCount(1)
+        ->and($orderItems->first()->product_id)->toBe($this->product->id)
+        ->and($orderItems->first()->quantity)->toBe(2)
+        ->and($orderItems->first()->unit_price)->toBe(5000)
+        ->and($orderItems->first()->total_price)->toBe(10000);
+});
+
+it('fails when cart is empty', function () {
+    $mockStripeService = Mockery::mock(StripeServiceContract::class);
+    $this->app->instance(StripeServiceContract::class, $mockStripeService);
+
+    $action = app(CreateCheckoutSession::class);
+    $action->handle($this->user, 'https://example.com/success', 'https://example.com/cancel');
+})->throws(InvalidArgumentException::class, 'Your cart is empty.');
+
+it('fails when course capacity is insufficient at checkout', function () {
+    CartItem::factory()->create([
+        'user_id' => $this->user->id,
+        'product_id' => $this->product->id,
+        'quantity' => 3,
+    ]);
+
+    // Fill all 5 spots
+    for ($i = 0; $i < 5; $i++) {
+        Enrollment::factory()->create(['course_id' => $this->course->id]);
+    }
+
+    $mockStripeService = Mockery::mock(StripeServiceContract::class);
+    $this->app->instance(StripeServiceContract::class, $mockStripeService);
+
+    $action = app(CreateCheckoutSession::class);
+    $action->handle($this->user, 'https://example.com/success', 'https://example.com/cancel');
+})->throws(InvalidArgumentException::class);
+
+it('creates an order with multiple cart items', function () {
+    $course2 = Course::factory()->create(['capacity' => 10]);
+    $product2 = Product::factory()->forCourse($course2)->create(['price' => 7500]);
+
+    CartItem::factory()->create([
+        'user_id' => $this->user->id,
+        'product_id' => $this->product->id,
+        'quantity' => 1,
+    ]);
+
+    CartItem::factory()->create([
+        'user_id' => $this->user->id,
+        'product_id' => $product2->id,
+        'quantity' => 2,
+    ]);
+
+    $mockSession = StripeSession::constructFrom([
+        'id' => 'cs_test_456',
+        'url' => 'https://checkout.stripe.com/test2',
+    ]);
+
+    $mockStripeService = Mockery::mock(StripeServiceContract::class);
+    $mockStripeService->shouldReceive('createCheckoutSession')
+        ->once()
+        ->andReturn($mockSession);
+
+    $this->app->instance(StripeServiceContract::class, $mockStripeService);
+
+    $action = app(CreateCheckoutSession::class);
+    $url = $action->handle($this->user, 'https://example.com/success', 'https://example.com/cancel');
+
+    $order = Order::query()->where('user_id', $this->user->id)->first();
+    expect($order->subtotal)->toBe(20000) // 5000 + (7500 * 2)
+        ->and($order->orderItems)->toHaveCount(2);
+});
diff --git a/tests/Feature/Actions/Store/CompleteOrderTest.php b/tests/Feature/Actions/Store/CompleteOrderTest.php
new file mode 100644
index 0000000..baa02f0
--- /dev/null
+++ b/tests/Feature/Actions/Store/CompleteOrderTest.php
@@ -0,0 +1,188 @@
+<?php
+
+declare(strict_types=1);
+
+use App\Actions\Store\CompleteOrder;
+use App\Contracts\StripeServiceContract;
+use App\Enums\OrderStatus;
+use App\Models\Course;
+use App\Models\Enrollment;
+use App\Models\Order;
+use App\Models\OrderItem;
+use App\Models\Product;
+use App\Models\User;
+
+beforeEach(function () {
+    $this->user = User::factory()->create();
+    $this->course = Course::factory()->create(['capacity' => 5]);
+    $this->product = Product::factory()->forCourse($this->course)->create(['price' => 5000]);
+});
+
+it('creates enrollments and marks order as completed', function () {
+    $order = Order::factory()->create([
+        'user_id' => $this->user->id,
+        'status' => OrderStatus::Pending,
+        'subtotal' => 10000,
+        'total' => 10000,
+        'stripe_payment_intent_id' => 'pi_test_123',
+    ]);
+
+    OrderItem::factory()->create([
+        'order_id' => $order->id,
+        'product_id' => $this->product->id,
+        'quantity' => 2,
+        'unit_price' => 5000,
+        'total_price' => 10000,
+    ]);
+
+    $mockStripeService = Mockery::mock(StripeServiceContract::class);
+    $this->app->instance(StripeServiceContract::class, $mockStripeService);
+
+    $action = app(CompleteOrder::class);
+    $result = $action->handle($order);
+
+    expect($result)->toBeTrue();
+    expect($order->refresh()->status)->toBe(OrderStatus::Completed);
+
+    // Should have created 2 enrollments
+    $enrollments = Enrollment::query()
+        ->where('course_id', $this->course->id)
+        ->where('user_id', $this->user->id)
+        ->get();
+
+    expect($enrollments)->toHaveCount(2);
+    expect($enrollments->every(fn ($e) => $e->student_id === null))->toBeTrue();
+});
+
+it('clears the users cart after completion', function () {
+    $order = Order::factory()->create([
+        'user_id' => $this->user->id,
+        'status' => OrderStatus::Pending,
+        'subtotal' => 5000,
+        'total' => 5000,
+    ]);
+
+    OrderItem::factory()->create([
+        'order_id' => $order->id,
+        'product_id' => $this->product->id,
+        'quantity' => 1,
+        'unit_price' => 5000,
+        'total_price' => 5000,
+    ]);
+
+    // Add a cart item
+    $this->user->cartItems()->create([
+        'product_id' => $this->product->id,
+        'quantity' => 1,
+    ]);
+
+    expect($this->user->cartItems()->count())->toBe(1);
+
+    $mockStripeService = Mockery::mock(StripeServiceContract::class);
+    $this->app->instance(StripeServiceContract::class, $mockStripeService);
+
+    $action = app(CompleteOrder::class);
+    $action->handle($order);
+
+    expect($this->user->cartItems()->count())->toBe(0);
+});
+
+it('fails and refunds when capacity is exceeded at completion time', function () {
+    $order = Order::factory()->create([
+        'user_id' => $this->user->id,
+        'status' => OrderStatus::Pending,
+        'subtotal' => 15000,
+        'total' => 15000,
+        'stripe_payment_intent_id' => 'pi_test_overcapacity',
+    ]);
+
+    OrderItem::factory()->create([
+        'order_id' => $order->id,
+        'product_id' => $this->product->id,
+        'quantity' => 3,
+        'unit_price' => 5000,
+        'total_price' => 15000,
+    ]);
+
+    // Fill 4 of 5 spots (only 1 remaining, but order wants 3)
+    for ($i = 0; $i < 4; $i++) {
+        Enrollment::factory()->create(['course_id' => $this->course->id]);
+    }
+
+    $mockStripeService = Mockery::mock(StripeServiceContract::class);
+    $mockStripeService->shouldReceive('refundPaymentIntent')
+        ->once()
+        ->with('pi_test_overcapacity');
+
+    $this->app->instance(StripeServiceContract::class, $mockStripeService);
+
+    $action = app(CompleteOrder::class);
+    $result = $action->handle($order);
+
+    expect($result)->toBeFalse();
+    expect($order->refresh()->status)->toBe(OrderStatus::Failed);
+
+    // No enrollments should have been created
+    $enrollments = Enrollment::query()
+        ->where('course_id', $this->course->id)
+        ->where('user_id', $this->user->id)
+        ->count();
+
+    expect($enrollments)->toBe(0);
+});
+
+it('skips if order is not pending', function () {
+    $order = Order::factory()->completed()->create([
+        'user_id' => $this->user->id,
+    ]);
+
+    $mockStripeService = Mockery::mock(StripeServiceContract::class);
+    $this->app->instance(StripeServiceContract::class, $mockStripeService);
+
+    $action = app(CompleteOrder::class);
+    $result = $action->handle($order);
+
+    expect($result)->toBeFalse();
+});
+
+it('handles multiple order items for different courses', function () {
+    $course2 = Course::factory()->create(['capacity' => 10]);
+    $product2 = Product::factory()->forCourse($course2)->create(['price' => 7500]);
+
+    $order = Order::factory()->create([
+        'user_id' => $this->user->id,
+        'status' => OrderStatus::Pending,
+        'subtotal' => 20000,
+        'total' => 20000,
+    ]);
+
+    OrderItem::factory()->create([
+        'order_id' => $order->id,
+        'product_id' => $this->product->id,
+        'quantity' => 2,
+        'unit_price' => 5000,
+        'total_price' => 10000,
+    ]);
+
+    OrderItem::factory()->create([
+        'order_id' => $order->id,
+        'product_id' => $product2->id,
+        'quantity' => 1,
+        'unit_price' => 7500,
+        'total_price' => 7500,
+    ]);
+
+    $mockStripeService = Mockery::mock(StripeServiceContract::class);
+    $this->app->instance(StripeServiceContract::class, $mockStripeService);
+
+    $action = app(CompleteOrder::class);
+    $result = $action->handle($order);
+
+    expect($result)->toBeTrue();
+
+    // 2 enrollments for course 1
+    expect(Enrollment::query()->where('course_id', $this->course->id)->count())->toBe(2);
+
+    // 1 enrollment for course 2
+    expect(Enrollment::query()->where('course_id', $course2->id)->count())->toBe(1);
+});
diff --git a/tests/Feature/Filament/Admin/Resources/OrderResourceTest.php b/tests/Feature/Filament/Admin/Resources/OrderResourceTest.php
new file mode 100644
index 0000000..165b310
--- /dev/null
+++ b/tests/Feature/Filament/Admin/Resources/OrderResourceTest.php
@@ -0,0 +1,76 @@
+<?php
+
+declare(strict_types=1);
+
+use App\Enums\OrderStatus;
+use App\Filament\Admin\Resources\Orders\Pages\ListOrders;
+use App\Filament\Admin\Resources\Orders\Pages\ViewOrder;
+use App\Models\Order;
+use App\Models\OrderItem;
+use App\Models\Product;
+use App\Models\User;
+use Filament\Facades\Filament;
+
+use function Pest\Livewire\livewire;
+
+beforeEach(function () {
+    Filament::setCurrentPanel('admin');
+    $this->product = Product::factory()->create(['price' => 5000]);
+});
+
+it('can render the orders index page', function () {
+    livewire(ListOrders::class)
+        ->assertOk();
+});
+
+it('can render the order view page', function () {
+    $order = Order::factory()->completed()->create();
+
+    OrderItem::factory()->create([
+        'order_id' => $order->id,
+        'product_id' => $this->product->id,
+    ]);
+
+    livewire(ViewOrder::class, [
+        'record' => $order->id,
+    ])
+        ->assertOk();
+});
+
+it('can list orders', function () {
+    $orders = Order::factory(3)->completed()->create();
+
+    livewire(ListOrders::class)
+        ->loadTable()
+        ->assertCanSeeTableRecords($orders);
+});
+
+it('can filter orders by status', function () {
+    $completedOrder = Order::factory()->completed()->create();
+    $pendingOrder = Order::factory()->create(['status' => OrderStatus::Pending]);
+
+    livewire(ListOrders::class)
+        ->loadTable()
+        ->filterTable('status', OrderStatus::Completed->value)
+        ->assertCanSeeTableRecords([$completedOrder])
+        ->assertCanNotSeeTableRecords([$pendingOrder]);
+});
+
+it('has required columns', function (string $column) {
+    livewire(ListOrders::class)
+        ->assertTableColumnExists($column);
+})->with(['id', 'user.full_name', 'user.email', 'status', 'total', 'created_at']);
+
+it('can search orders by customer name', function () {
+    $user1 = User::factory()->create(['first_name' => 'John', 'last_name' => 'Doe']);
+    $user2 = User::factory()->create(['first_name' => 'Jane', 'last_name' => 'Smith']);
+
+    $order1 = Order::factory()->completed()->create(['user_id' => $user1->id]);
+    $order2 = Order::factory()->completed()->create(['user_id' => $user2->id]);
+
+    livewire(ListOrders::class)
+        ->loadTable()
+        ->searchTable('John')
+        ->assertCanSeeTableRecords([$order1])
+        ->assertCanNotSeeTableRecords([$order2]);
+});
diff --git a/tests/Feature/Filament/Admin/Resources/ProductResourceTest.php b/tests/Feature/Filament/Admin/Resources/ProductResourceTest.php
new file mode 100644
index 0000000..a8b559b
--- /dev/null
+++ b/tests/Feature/Filament/Admin/Resources/ProductResourceTest.php
@@ -0,0 +1,52 @@
+<?php
+
+declare(strict_types=1);
+
+use App\Filament\Admin\Resources\Products\Pages\ListProducts;
+use App\Filament\Admin\Resources\Products\Pages\ViewProduct;
+use App\Models\Product;
+use Filament\Facades\Filament;
+
+use function Pest\Livewire\livewire;
+
+beforeEach(function () {
+    Filament::setCurrentPanel('admin');
+});
+
+it('can render the products index page', function () {
+    livewire(ListProducts::class)
+        ->assertOk();
+});
+
+it('can render the product view page', function () {
+    $product = Product::factory()->create();
+
+    livewire(ViewProduct::class, [
+        'record' => $product->id,
+    ])
+        ->assertOk();
+});
+
+it('can list products', function () {
+    $products = Product::factory(3)->create();
+
+    livewire(ListProducts::class)
+        ->loadTable()
+        ->assertCanSeeTableRecords($products);
+});
+
+it('has required columns', function (string $column) {
+    livewire(ListProducts::class)
+        ->assertTableColumnExists($column);
+})->with(['name', 'price', 'is_active', 'productable_type', 'created_at', 'updated_at']);
+
+it('can search products by name', function () {
+    $product1 = Product::factory()->create(['name' => 'Tap Dance 101']);
+    $product2 = Product::factory()->create(['name' => 'Ballet Basics']);
+
+    livewire(ListProducts::class)
+        ->loadTable()
+        ->searchTable('Tap Dance')
+        ->assertCanSeeTableRecords([$product1])
+        ->assertCanNotSeeTableRecords([$product2]);
+});
diff --git a/tests/Feature/Filament/User/Pages/CartTest.php b/tests/Feature/Filament/User/Pages/CartTest.php
new file mode 100644
index 0000000..d978a51
--- /dev/null
+++ b/tests/Feature/Filament/User/Pages/CartTest.php
@@ -0,0 +1,59 @@
+<?php
+
+declare(strict_types=1);
+
+use App\Filament\User\Pages\Cart;
+use App\Models\CartItem;
+use App\Models\Course;
+use App\Models\Product;
+use App\Models\User;
+use Filament\Facades\Filament;
+
+use function Pest\Livewire\livewire;
+
+beforeEach(function () {
+    Filament::setCurrentPanel('user');
+    $this->course = Course::factory()->create(['capacity' => 5]);
+    $this->product = Product::factory()->forCourse($this->course)->create(['price' => 5000]);
+});
+
+it('can render the cart page', function () {
+    livewire(Cart::class)
+        ->assertOk();
+});
+
+it('displays cart items for the authenticated user', function () {
+    $cartItem = CartItem::factory()->create([
+        'user_id' => auth()->id(),
+        'product_id' => $this->product->id,
+        'quantity' => 2,
+    ]);
+
+    livewire(Cart::class)
+        ->loadTable()
+        ->assertCanSeeTableRecords([$cartItem]);
+});
+
+it('does not display other users cart items', function () {
+    $otherUser = User::factory()->create();
+
+    $otherCartItem = CartItem::factory()->create([
+        'user_id' => $otherUser->id,
+        'product_id' => $this->product->id,
+    ]);
+
+    livewire(Cart::class)
+        ->loadTable()
+        ->assertCanNotSeeTableRecords([$otherCartItem]);
+});
+
+it('shows empty state when cart is empty', function () {
+    livewire(Cart::class)
+        ->loadTable()
+        ->assertSee('Your cart is empty');
+});
+
+it('has required columns', function (string $column) {
+    livewire(Cart::class)
+        ->assertTableColumnExists($column);
+})->with(['product.name', 'product.price', 'quantity', 'line_total']);
diff --git a/tests/Feature/Filament/User/Pages/StoreTest.php b/tests/Feature/Filament/User/Pages/StoreTest.php
new file mode 100644
index 0000000..2037a74
--- /dev/null
+++ b/tests/Feature/Filament/User/Pages/StoreTest.php
@@ -0,0 +1,50 @@
+<?php
+
+declare(strict_types=1);
+
+use App\Filament\User\Pages\Store;
+use App\Models\Course;
+use App\Models\Product;
+use Filament\Facades\Filament;
+
+use function Pest\Livewire\livewire;
+
+beforeEach(function () {
+    Filament::setCurrentPanel('user');
+    $this->course = Course::factory()->create(['capacity' => 5]);
+    $this->product = Product::factory()->forCourse($this->course)->create(['price' => 5000]);
+});
+
+it('can render the store page', function () {
+    livewire(Store::class)
+        ->assertOk();
+});
+
+it('displays available products', function () {
+    livewire(Store::class)
+        ->loadTable()
+        ->assertCanSeeTableRecords(Product::query()->available()->get());
+});
+
+it('does not display inactive products', function () {
+    $inactiveProduct = Product::factory()->inactive()->create();
+
+    livewire(Store::class)
+        ->loadTable()
+        ->assertCanSeeTableRecords([$this->product])
+        ->assertCanNotSeeTableRecords([$inactiveProduct]);
+});
+
+it('does not display products with zero price', function () {
+    $freeProduct = Product::factory()->create(['price' => 0]);
+
+    livewire(Store::class)
+        ->loadTable()
+        ->assertCanSeeTableRecords([$this->product])
+        ->assertCanNotSeeTableRecords([$freeProduct]);
+});
+
+it('has required columns', function (string $column) {
+    livewire(Store::class)
+        ->assertTableColumnExists($column);
+})->with(['name', 'description', 'price', 'available_spots']);
diff --git a/tests/Feature/Http/Controllers/StripeWebhookControllerTest.php b/tests/Feature/Http/Controllers/StripeWebhookControllerTest.php
new file mode 100644
index 0000000..bf704f0
--- /dev/null
+++ b/tests/Feature/Http/Controllers/StripeWebhookControllerTest.php
@@ -0,0 +1,174 @@
+<?php
+
+declare(strict_types=1);
+
+use App\Contracts\StripeServiceContract;
+use App\Enums\OrderStatus;
+use App\Http\Controllers\StripeWebhookController;
+use App\Models\Order;
+use App\Models\OrderItem;
+use App\Models\Product;
+use App\Models\User;
+use Illuminate\Http\Request;
+
+beforeEach(function () {
+    $this->product = Product::factory()->create(['price' => 5000]);
+});
+
+it('handles checkout session completed webhook', function () {
+    $user = User::factory()->create();
+
+    $order = Order::factory()->create([
+        'user_id' => $user->id,
+        'status' => OrderStatus::Pending,
+        'subtotal' => 5000,
+        'total' => 5000,
+        'stripe_checkout_session_id' => 'cs_test_webhook',
+    ]);
+
+    OrderItem::factory()->create([
+        'order_id' => $order->id,
+        'product_id' => $this->product->id,
+        'quantity' => 1,
+        'unit_price' => 5000,
+        'total_price' => 5000,
+    ]);
+
+    $event = new Stripe\Event;
+    $event->type = 'checkout.session.completed';
+    $event->data = (object) [
+        'object' => (object) [
+            'id' => 'cs_test_webhook',
+            'payment_intent' => 'pi_test_webhook',
+            'metadata' => (object) [
+                'order_id' => (string) $order->id,
+            ],
+        ],
+    ];
+
+    $mockStripeService = Mockery::mock(StripeServiceContract::class);
+    $mockStripeService->shouldReceive('constructWebhookEvent')
+        ->once()
+        ->andReturn($event);
+
+    $this->app->instance(StripeServiceContract::class, $mockStripeService);
+
+    $request = Request::create('/stripe/webhook', 'POST', [], [], [], [
+        'HTTP_STRIPE_SIGNATURE' => 'test_signature',
+    ]);
+
+    $controller = app(StripeWebhookController::class);
+    $response = $controller($request);
+
+    expect($response->getStatusCode())->toBe(200);
+    expect($response->getData(true))->toBe(['message' => 'Order processed']);
+
+    expect($order->refresh()->status)->toBe(OrderStatus::Completed);
+    expect($order->stripe_payment_intent_id)->toBe('pi_test_webhook');
+});
+
+it('returns 400 for invalid webhook signature', function () {
+    $mockStripeService = Mockery::mock(StripeServiceContract::class);
+    $mockStripeService->shouldReceive('constructWebhookEvent')
+        ->once()
+        ->andThrow(new Stripe\Exception\SignatureVerificationException('Invalid signature'));
+
+    $this->app->instance(StripeServiceContract::class, $mockStripeService);
+
+    $request = Request::create('/stripe/webhook', 'POST', [], [], [], [
+        'HTTP_STRIPE_SIGNATURE' => 'invalid_signature',
+    ]);
+
+    $controller = app(StripeWebhookController::class);
+    $response = $controller($request);
+
+    expect($response->getStatusCode())->toBe(400);
+    expect($response->getData(true))->toBe(['error' => 'Invalid signature']);
+});
+
+it('handles unrecognized event types gracefully', function () {
+    $event = new Stripe\Event;
+    $event->type = 'some.unknown.event';
+    $event->data = (object) ['object' => (object) []];
+
+    $mockStripeService = Mockery::mock(StripeServiceContract::class);
+    $mockStripeService->shouldReceive('constructWebhookEvent')
+        ->once()
+        ->andReturn($event);
+
+    $this->app->instance(StripeServiceContract::class, $mockStripeService);
+
+    $request = Request::create('/stripe/webhook', 'POST', [], [], [], [
+        'HTTP_STRIPE_SIGNATURE' => 'test_signature',
+    ]);
+
+    $controller = app(StripeWebhookController::class);
+    $response = $controller($request);
+
+    expect($response->getStatusCode())->toBe(200);
+    expect($response->getData(true))->toBe(['message' => 'Unhandled event type']);
+});
+
+it('handles payment intent failed webhook', function () {
+    $user = User::factory()->create();
+
+    $order = Order::factory()->create([
+        'user_id' => $user->id,
+        'status' => OrderStatus::Pending,
+        'stripe_payment_intent_id' => 'pi_test_failed',
+    ]);
+
+    $event = new Stripe\Event;
+    $event->type = 'payment_intent.payment_failed';
+    $event->data = (object) [
+        'object' => (object) [
+            'id' => 'pi_test_failed',
+        ],
+    ];
+
+    $mockStripeService = Mockery::mock(StripeServiceContract::class);
+    $mockStripeService->shouldReceive('constructWebhookEvent')
+        ->once()
+        ->andReturn($event);
+
+    $this->app->instance(StripeServiceContract::class, $mockStripeService);
+
+    $request = Request::create('/stripe/webhook', 'POST', [], [], [], [
+        'HTTP_STRIPE_SIGNATURE' => 'test_signature',
+    ]);
+
+    $controller = app(StripeWebhookController::class);
+    $response = $controller($request);
+
+    expect($response->getStatusCode())->toBe(200);
+    expect($order->refresh()->status)->toBe(OrderStatus::Failed);
+});
+
+it('returns 400 when checkout session is missing order_id metadata', function () {
+    $event = new Stripe\Event;
+    $event->type = 'checkout.session.completed';
+    $event->data = (object) [
+        'object' => (object) [
+            'id' => 'cs_test_no_meta',
+            'payment_intent' => 'pi_test',
+            'metadata' => (object) [],
+        ],
+    ];
+
+    $mockStripeService = Mockery::mock(StripeServiceContract::class);
+    $mockStripeService->shouldReceive('constructWebhookEvent')
+        ->once()
+        ->andReturn($event);
+
+    $this->app->instance(StripeServiceContract::class, $mockStripeService);
+
+    $request = Request::create('/stripe/webhook', 'POST', [], [], [], [
+        'HTTP_STRIPE_SIGNATURE' => 'test_signature',
+    ]);
+
+    $controller = app(StripeWebhookController::class);
+    $response = $controller($request);
+
+    expect($response->getStatusCode())->toBe(400);
+    expect($response->getData(true))->toBe(['error' => 'Missing order_id']);
+});
diff --git a/tests/Feature/Models/CourseTest.php b/tests/Feature/Models/CourseTest.php
new file mode 100644
index 0000000..13a8b06
--- /dev/null
+++ b/tests/Feature/Models/CourseTest.php
@@ -0,0 +1,45 @@
+<?php
+
+declare(strict_types=1);
+
+use App\Models\Course;
+use App\Models\Enrollment;
+use App\Models\Product;
+
+it('calculates available capacity correctly', function () {
+    $course = Course::factory()->create(['capacity' => 5]);
+
+    expect($course->availableCapacity())->toBe(5);
+
+    Enrollment::factory(3)->create(['course_id' => $course->id]);
+
+    expect($course->availableCapacity())->toBe(2);
+});
+
+it('returns zero when fully enrolled', function () {
+    $course = Course::factory()->create(['capacity' => 2]);
+
+    Enrollment::factory(2)->create(['course_id' => $course->id]);
+
+    expect($course->availableCapacity())->toBe(0);
+});
+
+it('has a product relationship', function () {
+    $course = Course::factory()->create();
+    $product = Product::factory()->forCourse($course)->create();
+
+    expect($course->product)->toBeInstanceOf(Product::class)
+        ->and($course->product->id)->toBe($product->id);
+});
+
+it('scopes available courses', function () {
+    $available = Course::factory()->create(['capacity' => 5]);
+    $full = Course::factory()->create(['capacity' => 1]);
+
+    Enrollment::factory()->create(['course_id' => $full->id]);
+
+    $results = Course::available()->get();
+
+    expect($results->pluck('id')->toArray())->toContain($available->id)
+        ->and($results->pluck('id')->toArray())->not->toContain($full->id);
+});
diff --git a/tests/Feature/Models/ProductTest.php b/tests/Feature/Models/ProductTest.php
new file mode 100644
index 0000000..3e50cd7
--- /dev/null
+++ b/tests/Feature/Models/ProductTest.php
@@ -0,0 +1,41 @@
+<?php
+
+declare(strict_types=1);
+
+use App\Models\Course;
+use App\Models\Product;
+
+it('scopes available products', function () {
+    $active = Product::factory()->create(['is_active' => true, 'price' => 5000]);
+    $inactive = Product::factory()->inactive()->create();
+    $zeroPriced = Product::factory()->create(['is_active' => true, 'price' => 0]);
+
+    $results = Product::query()->available()->get();
+
+    expect($results->pluck('id')->toArray())->toContain($active->id)
+        ->and($results->pluck('id')->toArray())->not->toContain($inactive->id)
+        ->and($results->pluck('id')->toArray())->not->toContain($zeroPriced->id);
+});
+
+it('formats price correctly', function () {
+    $product = Product::factory()->create(['price' => 15099]);
+
+    expect($product->formattedPrice())->toBe('$150.99');
+});
+
+it('morphs to a course', function () {
+    $course = Course::factory()->create();
+    $product = Product::factory()->forCourse($course)->create();
+
+    expect($product->productable)->toBeInstanceOf(Course::class)
+        ->and($product->productable->id)->toBe($course->id);
+});
+
+it('can be created without a productable', function () {
+    $product = Product::factory()->create([
+        'productable_type' => null,
+        'productable_id' => null,
+    ]);
+
+    expect($product->productable)->toBeNull();
+});
